{
  "hash": "f8859210f19d81d71a59806f92269a11",
  "result": {
    "markdown": "---\ntitle: \"Space\"\ndate: \"2023-11-06\"\ndate_end: \"2023-11-10\"\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/3.5.16/iframeResizer.min.js\" type=\"text/javascript\"></script>\n:::\n\n\nThere *is* a short lesson this week! You'll learn the basics of joining two different datasets together, both vertically and horizontally.\n\nThere are a few imaginary datasets I've created for you to play with:\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx\n## # A tibble: 3 × 2\n##      id some_variable\n##   <dbl> <chr>        \n## 1     1 x1           \n## 2     2 x2           \n## 3     3 x3\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny\n## # A tibble: 3 × 2\n##      id some_other_variable\n##   <dbl> <chr>              \n## 1     1 y1                 \n## 2     2 y2                 \n## 3     4 y4\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data\n## # A tibble: 9 × 5\n##   state  year unemployment inflation population\n##   <chr> <dbl>        <dbl>     <dbl>      <dbl>\n## 1 GA     2018          5         2          100\n## 2 GA     2019          5.3       1.8        200\n## 3 GA     2020          5.2       2.5        300\n## 4 NC     2018          6.1       1.8        350\n## 5 NC     2019          5.9       1.6        375\n## 6 NC     2020          5.3       1.8        400\n## 7 CO     2018          4.7       2.7        200\n## 8 CO     2019          4.4       2.6        300\n## 9 CO     2020          5.1       2.5        400\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data_2019\n## # A tibble: 3 × 4\n##   state unemployment inflation population\n##   <chr>        <dbl>     <dbl>      <dbl>\n## 1 GA             5.3       1.8        200\n## 2 NC             5.9       1.6        375\n## 3 CO             4.4       2.6        300\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_libraries\n## # A tibble: 6 × 4\n##   state  year libraries schools\n##   <chr> <dbl>     <dbl>   <dbl>\n## 1 CO     2018       230     470\n## 2 CO     2019       240     440\n## 3 CO     2020       270     510\n## 4 NC     2018       200     610\n## 5 NC     2019       210     590\n## 6 NC     2020       220     530\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_libraries_2019\n## # A tibble: 2 × 3\n##   state libraries schools\n##   <chr>     <dbl>   <dbl>\n## 1 CO          240     440\n## 2 NC          210     590\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npuerto_rico_data\n## # A tibble: 3 × 4\n##   state unemployment population  year\n##   <chr>        <dbl>      <dbl> <dbl>\n## 1 PR             3.1        150  2018\n## 2 PR             3.2        250  2019\n## 3 PR             3.3        350  2020\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstate_regions\n## # A tibble: 51 × 2\n##    region    state\n##    <chr>     <chr>\n##  1 West      AK   \n##  2 South     AL   \n##  3 South     AR   \n##  4 West      AZ   \n##  5 West      CA   \n##  6 West      CO   \n##  7 Northeast CT   \n##  8 South     DC   \n##  9 South     DE   \n## 10 South     FL   \n## # ℹ 41 more rows\n```\n:::\n\n\n\n## Combining datasets vertically\n\nRecall from the [Lord of the Rings data in exercise 3](/assignment/03-exercise.qmd) that you had to combine three different CSV files into dataset. You used `bind_rows()` to stack each of these on top of each other. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlotr <- bind_rows(fellowship, tt, rotk)\n```\n:::\n\n\nThat worked well because each of the individual data frames had the same columns in them, and R was able to line up the matching columns. If columns were missing, R would have placed `NA` in the appropriate locations.\n\n::: {.callout-important}\n### Your turn\n\nCombine `national_data` and `puerto_rico_data` into a single dataset named `us_data` using `bind_rows`. Pay attention to what happens with the inflation column. Also notice that the columns in the Puerto Rico data are in a different order.\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-12-lesson-joining1\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_12-joining-1/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-12-lesson-joining1\")'></iframe>\n:::\n\n\n## Combining datasets horizontally\n\nBinding rows vertically is the easiest way to combine two datasets, but most often you won't be doing that. You'll only do this if you're combining datasets that come from the same source, like if a state offers separate CSV files of the same data for each county. \n\nIn most cases, though, you'll need to combine completely different datasets, bringing one or more columns from one into another. With vertical combining, R needs column names with the same names in order to figure out where the data lines up. With horizontal combining, R needs values inside one or more columns to be the same in order to figure out where the data lines up.\n\nThere is technically a function named `bind_cols()`, but you'll rarely want to use it. It doesn't attempt to match any rows—it just glues two datasets together:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbind_cols(national_data, \n          # Repeat PR 3 times so that it has the same number of rows as national_data\n          bind_rows(puerto_rico_data, puerto_rico_data, puerto_rico_data))\n## New names:\n## • `state` -> `state...1`\n## • `year` -> `year...2`\n## • `unemployment` -> `unemployment...3`\n## • `population` -> `population...5`\n## • `state` -> `state...6`\n## • `unemployment` -> `unemployment...7`\n## • `population` -> `population...8`\n## • `year` -> `year...9`\n## # A tibble: 9 × 9\n##   state...1 year...2 unemployment...3 inflation population...5 state...6\n##   <chr>        <dbl>            <dbl>     <dbl>          <dbl> <chr>    \n## 1 GA            2018              5         2              100 PR       \n## 2 GA            2019              5.3       1.8            200 PR       \n## 3 GA            2020              5.2       2.5            300 PR       \n## 4 NC            2018              6.1       1.8            350 PR       \n## 5 NC            2019              5.9       1.6            375 PR       \n## 6 NC            2020              5.3       1.8            400 PR       \n## 7 CO            2018              4.7       2.7            200 PR       \n## 8 CO            2019              4.4       2.6            300 PR       \n## 9 CO            2020              5.1       2.5            400 PR       \n## # ℹ 3 more variables: unemployment...7 <dbl>, population...8 <dbl>,\n## #   year...9 <dbl>\n```\n:::\n\n\nThat's… not great.\n\nInstead, we need to use a function that is more careful about bringing in data. Fortunately there are a few good options:\n\n- `inner_join()`\n- `left_join()`\n- `right_join()`\n\nThe **most** helpful way of understanding these different functions [is to go here and stare at the animations for a little while](https://github.com/gadenbuie/tidyexplain#mutating-joins) to see which pieces of which dataset go where. (There are lots of others, like `full_join()`, `semi_join()`, and `anti_join()`, and they have helpful animations, but I rarely use those.)\n\nFor each of these functions, **you need at least one common ID column in both datasets** in order for R to know where things line up.\n\nLet's practice how these all work and see what the differences between them are.\n\n## `inner_join()`\n\nFirst, <a href=\"https://github.com/gadenbuie/tidyexplain#inner-join\" target=\"_blank\">go to this page in a new tab</a> and stare at the mesmerizing animation.\n\nLet's look at two datasets, `x` and `y`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx\n## # A tibble: 3 × 2\n##      id some_variable\n##   <dbl> <chr>        \n## 1     1 x1           \n## 2     2 x2           \n## 3     3 x3\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny\n## # A tibble: 3 × 2\n##      id some_other_variable\n##   <dbl> <chr>              \n## 1     1 y1                 \n## 2     2 y2                 \n## 3     4 y4\n```\n:::\n\n\nBoth datasets have an `id` column that is the same across each (though the values aren't necessarily the same). Because there's a shared column, we can join these two based on that column.\n\nIf we use `inner_join()`, the resulting dataset will only keep the rows from the first where there are matching values from the second:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_join(x, y, by = \"id\")\n## # A tibble: 2 × 3\n##      id some_variable some_other_variable\n##   <dbl> <chr>         <chr>              \n## 1     1 x1            y1                 \n## 2     2 x2            y2\n```\n:::\n\n\nNotice how it got rid of the row with `id = 3` from the first and the row with `id = 4` from the second. \n\nYou can also write this with pipes, which is really common when working with {dplyr}:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx %>% \n  inner_join(y, by = \"id\")\n## # A tibble: 2 × 3\n##      id some_variable some_other_variable\n##   <dbl> <chr>         <chr>              \n## 1     1 x1            y1                 \n## 2     2 x2            y2\n```\n:::\n\n\nLet's say we have two datasets: `national_data_2019` and `national_libraries_2019`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data_2019\n## # A tibble: 3 × 4\n##   state unemployment inflation population\n##   <chr>        <dbl>     <dbl>      <dbl>\n## 1 GA             5.3       1.8        200\n## 2 NC             5.9       1.6        375\n## 3 CO             4.4       2.6        300\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_libraries_2019\n## # A tibble: 2 × 3\n##   state libraries schools\n##   <chr>     <dbl>   <dbl>\n## 1 CO          240     440\n## 2 NC          210     590\n```\n:::\n\n\nWe want to bring the libraries and schools columns into the general national data. Notice how both datasets have a state column.\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `combined_data` that uses `inner_join()` to merge `national_data_2019` and `national_libraries_2019`.\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-12-lesson-joining2\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_12-joining-2/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-12-lesson-joining2\")'></iframe>\n:::\n\n\n## `left_join()`\n\nAgain, <a href=\"https://github.com/gadenbuie/tidyexplain#left-join\" target=\"_blank\">go to this page in a new tab</a> and stare at the animation.\n\nLeft joining is less destructive than inner joining. With left joining, any rows in the first dataset that don't have matches in the second *don't* get thrown away and instead are filled with `NA`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleft_join(x, y, by = \"id\")\n## # A tibble: 3 × 3\n##      id some_variable some_other_variable\n##   <dbl> <chr>         <chr>              \n## 1     1 x1            y1                 \n## 2     2 x2            y2                 \n## 3     3 x3            <NA>\n```\n:::\n\n\nNotice how the row with `id = 4` from the second dataset is gone, but the row with `id = 3` from the first is still there, with `NA` for `some_other_variable`.\n\nI find this much more useful when combining data. I often have a larger dataset with all the main variables I care about, perhaps with every combination of country and year over 20 years and 180 countries. If I find another dataset I want to join, and it has missing data for some of the years or countries, I don't want the combined data to throw away all the rows from the main big dataset that don't match! I still want those! \n\n*([Look at this for a real life example](https://stats.andrewheiss.com/canary-ngos/01_get-merge-data.html#final_clean_combined_data): I create a dataset I name `panel_skeleton` that is just all the combinations of countries and years (Afghanistan 1990, Afghanistan 1991, etc.), and then I bring in all sorts of other datasets that match the same countries and years. When there aren't matches, nothing in the skeleton gets thrown away—R just adds missing values instead.)*\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `combined_data` that uses `left_join()` to merge `national_data_2019` and `national_libraries_2019`.\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-12-lesson-joining5\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_12-joining-5/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-12-lesson-joining5\")'></iframe>\n:::\n\n\nLeft joining is also often surprisingly helpful for recoding lots of variables. Right now in our fake national data, we have a column for state, but it would be nice if we could have a column for region so we could facet or fill or color by region in a plot. Hunting around on the internet, you find this dataset that has a column for state and a column for abbreviations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstate_regions\n## # A tibble: 51 × 2\n##    region    state\n##    <chr>     <chr>\n##  1 West      AK   \n##  2 South     AL   \n##  3 South     AR   \n##  4 West      AZ   \n##  5 West      CA   \n##  6 West      CO   \n##  7 Northeast CT   \n##  8 South     DC   \n##  9 South     DE   \n## 10 South     FL   \n## # ℹ 41 more rows\n```\n:::\n\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `national_data_with_region` that uses `left_join()` to combine `national_data_2019` with `state_regions`.\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-12-lesson-joining3\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_12-joining-3/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-12-lesson-joining3\")'></iframe>\n:::\n\n\nBecause `left_join()` only keeps rows from the second dataset that match the first, we don't actually bring in all 50 rows from the `state_regions` data—only the rows that match the first dataset (`national_data_2019`) come over. We could have done with if some massive recoding (`mutate(region = ifelse(state == \"GA\" | state == \"NC\", \"South\", ifelse(state == \"CO\"), \"West\", NA))`), but that's awful. Left joining is far easier here.\n\nYou can also join by multiple columns. So far we've been working with just `national_data_2019`, but if you look at `national_data`, you'll see there are rows for different years across these states:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data\n## # A tibble: 9 × 5\n##   state  year unemployment inflation population\n##   <chr> <dbl>        <dbl>     <dbl>      <dbl>\n## 1 GA     2018          5         2          100\n## 2 GA     2019          5.3       1.8        200\n## 3 GA     2020          5.2       2.5        300\n## 4 NC     2018          6.1       1.8        350\n## 5 NC     2019          5.9       1.6        375\n## 6 NC     2020          5.3       1.8        400\n## 7 CO     2018          4.7       2.7        200\n## 8 CO     2019          4.4       2.6        300\n## 9 CO     2020          5.1       2.5        400\n```\n:::\n\n\nPreviously, we've been specifying the ID column with `by = \"state\"`, but now we have two ID columns: `state` and `year`. We can specify both with `by = c(\"state\", \"year\")`.\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `national_data_combined` that uses `left_join()` to combine `national_data` with `national_libraries` by state and year.\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-12-lesson-joining4\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_12-joining-4/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-12-lesson-joining4\")'></iframe>\n:::\n\n\nIf one dataset has things like state and year, but another only has state, `left_join()` will still work, but it will only join where the state is the same. For instance, here's what happens when we join the region data to the yearly national data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data_with_region <- national_data %>% \n  left_join(state_regions, by = \"state\")\nnational_data_with_region\n## # A tibble: 9 × 6\n##   state  year unemployment inflation population region\n##   <chr> <dbl>        <dbl>     <dbl>      <dbl> <chr> \n## 1 GA     2018          5         2          100 South \n## 2 GA     2019          5.3       1.8        200 South \n## 3 GA     2020          5.2       2.5        300 South \n## 4 NC     2018          6.1       1.8        350 South \n## 5 NC     2019          5.9       1.6        375 South \n## 6 NC     2020          5.3       1.8        400 South \n## 7 CO     2018          4.7       2.7        200 West  \n## 8 CO     2019          4.4       2.6        300 West  \n## 9 CO     2020          5.1       2.5        400 West\n```\n:::\n\n\nThe \"South\" region gets added to every row where the state is \"GA\" and \"NC\", even though those rows only appear once in `state_regions`. `left_join()` will still match all the values even if states are repeated. Magic!\n\n## Common column names\n\nSo far, the column names in both datasets have been the same, which has greatly simplified life. In fact, if the columns have the same name, we can technically leave out the `by` argument and R will guess:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data %>% \n  left_join(national_libraries)\n## Joining with `by = join_by(state, year)`\n## # A tibble: 9 × 7\n##   state  year unemployment inflation population libraries schools\n##   <chr> <dbl>        <dbl>     <dbl>      <dbl>     <dbl>   <dbl>\n## 1 GA     2018          5         2          100        NA      NA\n## 2 GA     2019          5.3       1.8        200        NA      NA\n## 3 GA     2020          5.2       2.5        300        NA      NA\n## 4 NC     2018          6.1       1.8        350       200     610\n## 5 NC     2019          5.9       1.6        375       210     590\n## 6 NC     2020          5.3       1.8        400       220     530\n## 7 CO     2018          4.7       2.7        200       230     470\n## 8 CO     2019          4.4       2.6        300       240     440\n## 9 CO     2020          5.1       2.5        400       270     510\n```\n:::\n\n\nIt's good practice to be specific about the columns you want and actually use `by`, but I will often run `left_join()` without it and then copy the message that it generates (\"`by = c(\"state\", \"year\")`\") and paste it into my code. \n\nBut what if the column names don't match? Let's rename the state column in our state/region table for fun:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstate_regions_different <- state_regions %>% \n  rename(ST = state)\nstate_regions_different\n## # A tibble: 51 × 2\n##    region    ST   \n##    <chr>     <chr>\n##  1 West      AK   \n##  2 South     AL   \n##  3 South     AR   \n##  4 West      AZ   \n##  5 West      CA   \n##  6 West      CO   \n##  7 Northeast CT   \n##  8 South     DC   \n##  9 South     DE   \n## 10 South     FL   \n## # ℹ 41 more rows\n```\n:::\n\n\nNow watch what happens when we try to join the datasets:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data %>% \n  left_join(state_regions_different)\n## Error in `left_join()`:\n## ! `by` must be supplied when `x` and `y` have no common variables.\n## ℹ Use `cross_join()` to perform a cross-join.\n```\n:::\n\n\nThere are no common variables, so we get an error. The `state` and `ST` columns really are common variables, but R doesn't know that.\n\nWe have two options:\n\n1. Rename one of the columns so it matches (either change `state` to `ST` or change `ST` to `state`)\n2. Tell `left_join()` which columns are the same\n\nWe can do option two by modifying the `by` argument like so:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data %>% \n  left_join(state_regions_different, by = c(\"state\" = \"ST\"))\n## # A tibble: 9 × 6\n##   state  year unemployment inflation population region\n##   <chr> <dbl>        <dbl>     <dbl>      <dbl> <chr> \n## 1 GA     2018          5         2          100 South \n## 2 GA     2019          5.3       1.8        200 South \n## 3 GA     2020          5.2       2.5        300 South \n## 4 NC     2018          6.1       1.8        350 South \n## 5 NC     2019          5.9       1.6        375 South \n## 6 NC     2020          5.3       1.8        400 South \n## 7 CO     2018          4.7       2.7        200 West  \n## 8 CO     2019          4.4       2.6        300 West  \n## 9 CO     2020          5.1       2.5        400 West\n```\n:::\n\n\n\n## `right_join()`\n\nOnce again, <a href=\"https://github.com/gadenbuie/tidyexplain#right-join\" target=\"_blank\">go to this page in a new tab</a> and watch the animation.\n\n`right_join()` works exactly like `left_join()`, but in reverse. The *second* dataset is the base data. Any rows in the second dataset that don't match in the first will be kept, and any rows from the first that don't match will get thrown away.\n\nWatch what happens if we right join `national_data` and `state_regions`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnational_data %>% \n  right_join(state_regions, by = \"state\")\n## # A tibble: 57 × 6\n##    state  year unemployment inflation population region\n##    <chr> <dbl>        <dbl>     <dbl>      <dbl> <chr> \n##  1 GA     2018          5         2          100 South \n##  2 GA     2019          5.3       1.8        200 South \n##  3 GA     2020          5.2       2.5        300 South \n##  4 NC     2018          6.1       1.8        350 South \n##  5 NC     2019          5.9       1.6        375 South \n##  6 NC     2020          5.3       1.8        400 South \n##  7 CO     2018          4.7       2.7        200 West  \n##  8 CO     2019          4.4       2.6        300 West  \n##  9 CO     2020          5.1       2.5        400 West  \n## 10 AK       NA         NA        NA           NA West  \n## # ℹ 47 more rows\n```\n:::\n\n\nYikes. R kept all the rows in `state_regions`, brought in the columns from `national_data` and filled most of the new columns with `NA`, and then repeated Colorado (and NC and GA) three times for each of the years from `national_data`. That's a mess.\n\nIf we reverse the order, we'll get the correct merged data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstate_regions %>% \n  right_join(national_data, by = \"state\")\n## # A tibble: 9 × 6\n##   region state  year unemployment inflation population\n##   <chr>  <chr> <dbl>        <dbl>     <dbl>      <dbl>\n## 1 West   CO     2018          4.7       2.7        200\n## 2 West   CO     2019          4.4       2.6        300\n## 3 West   CO     2020          5.1       2.5        400\n## 4 South  GA     2018          5         2          100\n## 5 South  GA     2019          5.3       1.8        200\n## 6 South  GA     2020          5.2       2.5        300\n## 7 South  NC     2018          6.1       1.8        350\n## 8 South  NC     2019          5.9       1.6        375\n## 9 South  NC     2020          5.3       1.8        400\n```\n:::\n\n\nI rarely use `right_join()` because I find it more intuitive to just use `left_join()` since in my head, I'm taking a dataset and stacking columns onto the end of it. If you want to right join instead, neat—just remember to order things correctly.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}