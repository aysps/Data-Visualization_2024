{
  "hash": "fa9ece0e9b0a4603eeac24b523b7181b",
  "result": {
    "markdown": "---\ntitle: \"Amounts and proportions\"\ndate: \"2023-09-11\"\ndate_end: \"2023-09-15\"\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/3.5.16/iframeResizer.min.js\" type=\"text/javascript\"></script>\n:::\n\n\nWhen you visualize proportions with ggplot, you'll typically go through a two-step process:\n\n1. Summarize the data with {dplyr} (typically with a combination of  `group_by()` and `summarize()`)\n2. Plot the summarized data\n\n\n## Manipulating data with {dplyr}\n\nYou had some experience with {dplyr} functions in the RStudio primers, but we'll briefly review them here.\n\nThere are 6 important verbs that you'll typically use when working with data:\n\n- Extract rows/cases with `filter()`\n- Extract columns/variables with `select()`\n- Arrange/sort rows with `arrange()`\n- Make new columns/variables with `mutate()`\n- Make group summaries with `group_by %>% summarize()`\n\nEvery {dplyr} verb follows the same pattern. The first argument is always a data frame, and the function always returns a data frame:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nVERB(DATA_TO_TRANSFORM, STUFF_IT_DOES)\n```\n:::\n\n\n### Filtering with `filter()`\n\nThe `filter()` function takes two arguments: a data frame to transform, and a set of tests. It will return each row for which the test is TRUE.\n\nThis code, for instance, will look at the `gapminder` dataset and return all rows where `country` is equal to \"Denmark\":\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfilter(gapminder, country == \"Denmark\")\n## # A tibble: 12 × 6\n##    country continent  year lifeExp     pop gdpPercap\n##    <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Denmark Europe     1952    70.8 4334000     9692.\n##  2 Denmark Europe     1957    71.8 4487831    11100.\n##  3 Denmark Europe     1962    72.4 4646899    13583.\n##  4 Denmark Europe     1967    73.0 4838800    15937.\n##  5 Denmark Europe     1972    73.5 4991596    18866.\n##  6 Denmark Europe     1977    74.7 5088419    20423.\n##  7 Denmark Europe     1982    74.6 5117810    21688.\n##  8 Denmark Europe     1987    74.8 5127024    25116.\n##  9 Denmark Europe     1992    75.3 5171393    26407.\n## 10 Denmark Europe     1997    76.1 5283663    29804.\n## 11 Denmark Europe     2002    77.2 5374693    32167.\n## 12 Denmark Europe     2007    78.3 5468120    35278.\n```\n:::\n\n\nNotice that there are two equal signs (`==`). This is because it's a logical test, similar to greater than (`>`) or less than (`<`). When you use a single equal sign, you set an argument (like `data = gapminder`); when you use two, you are doing a test. There are lots of different ways to do logical tests:\n\n| Test        | Meaning                  |\n| ----------- | ------------------------ |\n| `x < y`     | Less than                |\n| `x > y`     | Greater than             |\n| `x == y`    | Equal to                 |\n| `x <= y`    | Less than or equal to    |\n| `x >= y`    | Greater than or equal to |\n| `x != y`    | Not equal to             |\n| `x %in% y`  | In (group membership)    |\n| `is.na(x)`  | Is missing               |\n| `!is.na(x)` | Is not missing           |\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and logical tests to show:\n\n1. The data for Canada\n2. All data for countries in Oceania\n3. Rows where life expectancy is greater than 82\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr1\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-1/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr1\")'></iframe>\n:::\n\n\nYou can also use multiple conditions, and these will extract rows that meet every test. By default, if you separate the tests with a comma, R will consider this an \"and\" test and find rows that are *both* Denmark and greater than 2000.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfilter(gapminder, country == \"Denmark\", year > 2000)\n## # A tibble: 2 × 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Denmark Europe     2002    77.2 5374693    32167.\n## 2 Denmark Europe     2007    78.3 5468120    35278.\n```\n:::\n\n\nYou can also use \"or\" with \"`|`\" and \"not\" with \"`!`\":\n\n| Operator | Meaning |\n| -------- | ------- |\n| `a & b`  | and     |\n| `a | b`  | or      |\n| `!a`     | not     |\n\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and logical tests to show:\n\n1. Canada before 1970\n2. Countries where life expectancy in 2007 is below 50\n3. Countries where life expectancy in 2007 is below 50 and are not in Africa\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr2\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-2/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr2\")'></iframe>\n:::\n\n\nBeware of some common mistakes! You can't collapse multiple tests into one. Instead, use two separate tests:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# This won't work!\nfilter(gapminder, 1960 < year < 1980)\n\n# This will work\nfilter(gapminder, 1960 < year, year < 1980)\n```\n:::\n\n\nAlso, you can avoid stringing together lots of tests by using the `%in%` operator, which checks to see if a value is in a list of values.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# This works, but is tedious\nfilter(gapminder, \n       country == \"Mexico\" | country == \"Canada\" | country == \"United States\")\n\n# This is more concise and easier to add other countries later\nfilter(gapminder, \n       country %in% c(\"Mexico\", \"Canada\", \"United States\"))\n```\n:::\n\n\n### Adding new columns with `mutate()`\n\nYou create new columns with the `mutate()` function. You can create a single column like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmutate(gapminder, gdp = gdpPercap * pop)\n## # A tibble: 1,704 × 7\n##    country     continent  year lifeExp      pop gdpPercap          gdp\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n##  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n##  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n##  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n##  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n## 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n## # ℹ 1,694 more rows\n```\n:::\n\n\nAnd you can create multiple columns by including a comma-separated list of new columns to create:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmutate(gapminder, gdp = gdpPercap * pop,\n                  pop_mill = round(pop / 1000000))\n## # A tibble: 1,704 × 8\n##    country     continent  year lifeExp      pop gdpPercap          gdp pop_mill\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>    <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.        8\n##  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.        9\n##  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.       10\n##  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.       12\n##  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.       13\n##  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.       15\n##  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.       13\n##  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.       14\n##  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.       16\n## 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.       22\n## # ℹ 1,694 more rows\n```\n:::\n\n\nYou can also do conditional tests within `mutate()` using the `ifelse()` function. This works like the `=IFELSE` function in Excel. Feed the function three arguments: (1) a test, (2) the value if the test is true, and (3) the value if the test is false:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nifelse(TEST, VALUE_IF_TRUE, VALUE_IF_FALSE)\n```\n:::\n\n\nWe can create a new column that is a binary indicator for whether the country's row is after 1960:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmutate(gapminder, after_1960 = ifelse(year > 1960, TRUE, FALSE))\n## # A tibble: 1,704 × 7\n##    country     continent  year lifeExp      pop gdpPercap after_1960\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl> <lgl>     \n##  1 Afghanistan Asia       1952    28.8  8425333      779. FALSE     \n##  2 Afghanistan Asia       1957    30.3  9240934      821. FALSE     \n##  3 Afghanistan Asia       1962    32.0 10267083      853. TRUE      \n##  4 Afghanistan Asia       1967    34.0 11537966      836. TRUE      \n##  5 Afghanistan Asia       1972    36.1 13079460      740. TRUE      \n##  6 Afghanistan Asia       1977    38.4 14880372      786. TRUE      \n##  7 Afghanistan Asia       1982    39.9 12881816      978. TRUE      \n##  8 Afghanistan Asia       1987    40.8 13867957      852. TRUE      \n##  9 Afghanistan Asia       1992    41.7 16317921      649. TRUE      \n## 10 Afghanistan Asia       1997    41.8 22227415      635. TRUE      \n## # ℹ 1,694 more rows\n```\n:::\n\n\nWe can also use text labels instead of `TRUE` and `FALSE`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmutate(gapminder, \n       after_1960 = ifelse(year > 1960, \"After 1960\", \"Before 1960\"))\n## # A tibble: 1,704 × 7\n##    country     continent  year lifeExp      pop gdpPercap after_1960 \n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl> <chr>      \n##  1 Afghanistan Asia       1952    28.8  8425333      779. Before 1960\n##  2 Afghanistan Asia       1957    30.3  9240934      821. Before 1960\n##  3 Afghanistan Asia       1962    32.0 10267083      853. After 1960 \n##  4 Afghanistan Asia       1967    34.0 11537966      836. After 1960 \n##  5 Afghanistan Asia       1972    36.1 13079460      740. After 1960 \n##  6 Afghanistan Asia       1977    38.4 14880372      786. After 1960 \n##  7 Afghanistan Asia       1982    39.9 12881816      978. After 1960 \n##  8 Afghanistan Asia       1987    40.8 13867957      852. After 1960 \n##  9 Afghanistan Asia       1992    41.7 16317921      649. After 1960 \n## 10 Afghanistan Asia       1997    41.8 22227415      635. After 1960 \n## # ℹ 1,694 more rows\n```\n:::\n\n\n::: {.callout-important}\n### Your turn\n\nUse `mutate()` to:\n\n1. Add an `africa` column that is TRUE if the country is on the African continent\n2. Add a column for logged GDP per capita\n3. Add an `africa_asia` column that says “Africa or Asia” if the country is in Africa or Asia, and “Not Africa or Asia” if it’s not\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr3\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-3/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr3\")'></iframe>\n:::\n\n\n### Combining multiple verbs with pipes (`%>%`)\n\nWhat if you want to filter to include only rows from 2002 *and* make a new column with the logged GDP per capita? Doing this requires both `filter()` and `mutate()`, so we need to find a way to use both at once.\n\nOne solution is to use intermediate variables for each step:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder_2002_filtered <- filter(gapminder, year == 2002)\n\ngapminder_2002_logged <- mutate(gapminder_2002_filtered, log_gdpPercap = log(gdpPercap))\n```\n:::\n\n\nThat works fine, but your environment panel will start getting full of lots of intermediate data frames.\n\nAnother solution is to nest the functions inside each other. Remember that all {dplyr} functions return data frames, so you can feed the results of one into another:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfilter(mutate(gapminder, log_gdpPercap = log(gdpPercap)), \n       year == 2002)\n```\n:::\n\n\nThat works too, but it gets *really* complicated once you have even more functions, and it's hard to keep track of which function's arguments go where. I'd avoid doing this entirely.\n\nOne really nice solution is to use a pipe, or `%>%`. **The pipe takes an object on the left and passes it as the first argument of the function on the right**.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# gapminder will automatically get placed in the _____ spot\ngapminder %>% filter(_____, country == \"Canada\")\n```\n:::\n\n\nThese two lines of code do the same thing:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfilter(gapminder, country == \"Canada\")\n\ngapminder %>% filter(country == \"Canada\")\n```\n:::\n\n\nUsing pipes, you can start with a data frame, pass it to one verb, then pass the output of that verb to the next verb, and so on. **When reading any code with a `%>%`, it's easiest to read the `%>%` as \"and then\".** This would read:\n\n> Take the `gapminder` dataset *and then* filter it so that it only has rows from 2002 *and then* add a new column with the logged GDP per capita\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(year == 2002) %>% \n  mutate(log_gdpPercap = log(gdpPercap))\n```\n:::\n\n\nHere's another way to think about pipes more conceptually. This isn't valid R code, obviously, but imagine you're going to take yourself, and then wake up, get out of bed, get dressed, and leave the house. Writing that whole process as nested functions would look like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleave_house(get_dressed(get_out_of_bed(wake_up(me, time = \"8:00\"), side = \"correct\"), pants = TRUE, shirt = TRUE), car = TRUE, bike = FALSE)\n```\n:::\n\n\nInstead of nesting everything, we can use pipes to chain these together. This would read\n\n> Take myself, *and then* wake up at 8:00, *and then* get out of bed on the correct side, *and then* get dressed with pants and a shirt, *and then* leave the house in a car\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nme %>% \n  wake_up(time = \"8:00\") %>% \n  get_out_of_bed(side = \"correct\") %>% \n  get_dressed(pants = TRUE, shirt = TRUE) %>% \n  leave_house(car = TRUE, bike = FALSE)\n```\n:::\n\n\n### Summarizing data by groups with `group_by() %>% summarize()`\n\nThe `summarize()` verb takes an entire frame and calculates summary information about it. For instance, this will find the average life expectancy for the whole `gapminder` data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% summarize(mean_life = mean(lifeExp))\n## # A tibble: 1 × 1\n##   mean_life\n##       <dbl>\n## 1      59.5\n```\n:::\n\n\nYou can also make multiple summary variables, just like `mutate()`, and it will return a column for each:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% summarize(mean_life = mean(lifeExp),\n                        min_life = min(lifeExp))\n## # A tibble: 1 × 2\n##   mean_life min_life\n##       <dbl>    <dbl>\n## 1      59.5     23.6\n```\n:::\n\n\n::: {.callout-important}\n### Your turn\n\nUse `summarize()` to calculate:\n\n1. The first (minimum) year in the `gapminder` dataset\n2. The last (maximum) year in the dataset\n3. The number of rows in the dataset (use the [{dplyr} cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))\n4. The number of distinct countries in the dataset (use the [{dplyr} cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr4\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-4/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr4\")'></iframe>\n:::\n\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and `summarize()` to calculate the median life expectancy on the African continent in 2007:\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr5\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-5/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr5\")'></iframe>\n:::\n\n\nNotice that `summarize()` on its own summarizes the whole dataset, so you only get a single row back. These values are the averages and minimums for the entire data frame. If you group your data into separate subgroups, you can use `summarize()` to calculate summary statistics for each group. Do this with `group_by()`.\n\nThe `group_by()` function puts rows into groups based on values in a column. If you run this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% group_by(continent)\n## # A tibble: 1,704 × 6\n## # Groups:   continent [5]\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ℹ 1,694 more rows\n```\n:::\n\n\n…you won't see anything different! R has put the dataset into separate invisible groups behind the scenes, but you haven't done anything with those groups, so nothing has really happened. If you do things with those groups with `summarize()`, though, `group_by()` becomes much more useful.\n\nFor instance, this will take the `gapminder` data frame, group it by continent, and then summarize it by calculating the number of distinct countries in each group. It will return *one row for each group*, so there should be a row for each continent:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% \n  group_by(continent) %>% \n  summarize(n_countries = n_distinct(country)) \n## # A tibble: 5 × 2\n##   continent n_countries\n##   <fct>           <int>\n## 1 Africa             52\n## 2 Americas           25\n## 3 Asia               33\n## 4 Europe             30\n## 5 Oceania             2\n```\n:::\n\n\nYou can calculate multiple summary statistics, as before:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% \n  group_by(continent) %>% \n  summarize(n_countries = n_distinct(country),\n            avg_life_exp = mean(lifeExp)) \n## # A tibble: 5 × 3\n##   continent n_countries avg_life_exp\n##   <fct>           <int>        <dbl>\n## 1 Africa             52         48.9\n## 2 Americas           25         64.7\n## 3 Asia               33         60.1\n## 4 Europe             30         71.9\n## 5 Oceania             2         74.3\n```\n:::\n\n\n::: {.callout-important}\n### Your turn\n\nFind the minimum, maximum, and median life expectancy for each continent:\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr6\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-6/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr6\")'></iframe>\n:::\n\n\n::: {.callout-important}\n### Your turn\n\nFind the minimum, maximum, and median life expectancy for each continent in 2007 only:\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n<iframe style=\"margin: 0px auto; min-width: 100%; overflow: hidden; height: 801px;\" id=\"learnr-04-lesson-dplyr7\" class=\"interactive\" src=\"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-7/\" scrolling=\"no\" frameborder=\"no\" onload='iFrameResize({}, \"#learnr-04-lesson-dplyr7\")'></iframe>\n:::\n\n\nFinally, you can group by multiple columns and R will create subgroups for every combination of the groups and return the number of rows of combinations. For instance, we can calculate the average life expectancy by both year and continent and we'll get 60 rows, since there are 5 continents and 12 years (5 × 12 = 60):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% \n  group_by(continent, year) %>% \n  summarize(avg_life_exp = mean(lifeExp)) \n## # A tibble: 60 × 3\n## # Groups:   continent [5]\n##    continent  year avg_life_exp\n##    <fct>     <int>        <dbl>\n##  1 Africa     1952         39.1\n##  2 Africa     1957         41.3\n##  3 Africa     1962         43.3\n##  4 Africa     1967         45.3\n##  5 Africa     1972         47.5\n##  6 Africa     1977         49.6\n##  7 Africa     1982         51.6\n##  8 Africa     1987         53.3\n##  9 Africa     1992         53.6\n## 10 Africa     1997         53.6\n## # ℹ 50 more rows\n```\n:::\n\n\n\n### Selecting with `select()`\n\nThe last two verbs are far simpler than `filter()`, `mutate()`, and `group_by() %>% summarize()`.\n\nYou can choose specific columns with the `select()` verb. This will only keep two columns: `lifeExp` and `year`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% select(lifeExp, year)\n## # A tibble: 1,704 × 2\n##    lifeExp  year\n##      <dbl> <int>\n##  1    28.8  1952\n##  2    30.3  1957\n##  3    32.0  1962\n##  4    34.0  1967\n##  5    36.1  1972\n##  6    38.4  1977\n##  7    39.9  1982\n##  8    40.8  1987\n##  9    41.7  1992\n## 10    41.8  1997\n## # ℹ 1,694 more rows\n```\n:::\n\n\nYou can remove specific columns by prefacing the column names with `-`, like `-lifeExp`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% select(-lifeExp)\n## # A tibble: 1,704 × 5\n##    country     continent  year      pop gdpPercap\n##    <fct>       <fct>     <int>    <int>     <dbl>\n##  1 Afghanistan Asia       1952  8425333      779.\n##  2 Afghanistan Asia       1957  9240934      821.\n##  3 Afghanistan Asia       1962 10267083      853.\n##  4 Afghanistan Asia       1967 11537966      836.\n##  5 Afghanistan Asia       1972 13079460      740.\n##  6 Afghanistan Asia       1977 14880372      786.\n##  7 Afghanistan Asia       1982 12881816      978.\n##  8 Afghanistan Asia       1987 13867957      852.\n##  9 Afghanistan Asia       1992 16317921      649.\n## 10 Afghanistan Asia       1997 22227415      635.\n## # ℹ 1,694 more rows\n```\n:::\n\n\nYou can also rename columns using `select()`. Follow this pattern: `select(old_name = new_name)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% select(year, country, life_expectancy = lifeExp)\n## # A tibble: 1,704 × 3\n##     year country     life_expectancy\n##    <int> <fct>                 <dbl>\n##  1  1952 Afghanistan            28.8\n##  2  1957 Afghanistan            30.3\n##  3  1962 Afghanistan            32.0\n##  4  1967 Afghanistan            34.0\n##  5  1972 Afghanistan            36.1\n##  6  1977 Afghanistan            38.4\n##  7  1982 Afghanistan            39.9\n##  8  1987 Afghanistan            40.8\n##  9  1992 Afghanistan            41.7\n## 10  1997 Afghanistan            41.8\n## # ℹ 1,694 more rows\n```\n:::\n\n\nAlternatively, there's a special `rename()` verb that will, um, rename, while keeping all the other columns:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% rename(life_expectancy = lifeExp)\n## # A tibble: 1,704 × 6\n##    country     continent  year life_expectancy      pop gdpPercap\n##    <fct>       <fct>     <int>           <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952            28.8  8425333      779.\n##  2 Afghanistan Asia       1957            30.3  9240934      821.\n##  3 Afghanistan Asia       1962            32.0 10267083      853.\n##  4 Afghanistan Asia       1967            34.0 11537966      836.\n##  5 Afghanistan Asia       1972            36.1 13079460      740.\n##  6 Afghanistan Asia       1977            38.4 14880372      786.\n##  7 Afghanistan Asia       1982            39.9 12881816      978.\n##  8 Afghanistan Asia       1987            40.8 13867957      852.\n##  9 Afghanistan Asia       1992            41.7 16317921      649.\n## 10 Afghanistan Asia       1997            41.8 22227415      635.\n## # ℹ 1,694 more rows\n```\n:::\n\n\n### Arranging data with `arrange()`\n\nThe `arrange()` verb sorts data. By default it sorts ascendingly, putting the lowest values first:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% arrange(lifeExp)\n## # A tibble: 1,704 × 6\n##    country      continent  year lifeExp     pop gdpPercap\n##    <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Rwanda       Africa     1992    23.6 7290203      737.\n##  2 Afghanistan  Asia       1952    28.8 8425333      779.\n##  3 Gambia       Africa     1952    30    284320      485.\n##  4 Angola       Africa     1952    30.0 4232095     3521.\n##  5 Sierra Leone Africa     1952    30.3 2143249      880.\n##  6 Afghanistan  Asia       1957    30.3 9240934      821.\n##  7 Cambodia     Asia       1977    31.2 6978607      525.\n##  8 Mozambique   Africa     1952    31.3 6446316      469.\n##  9 Sierra Leone Africa     1957    31.6 2295678     1004.\n## 10 Burkina Faso Africa     1952    32.0 4469979      543.\n## # ℹ 1,694 more rows\n```\n:::\n\n\nYou can reverse that by wrapping the column name with `desc()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% arrange(desc(lifeExp))\n## # A tibble: 1,704 × 6\n##    country          continent  year lifeExp       pop gdpPercap\n##    <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n##  1 Japan            Asia       2007    82.6 127467972    31656.\n##  2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n##  3 Japan            Asia       2002    82   127065841    28605.\n##  4 Iceland          Europe     2007    81.8    301931    36181.\n##  5 Switzerland      Europe     2007    81.7   7554661    37506.\n##  6 Hong Kong, China Asia       2002    81.5   6762476    30209.\n##  7 Australia        Oceania    2007    81.2  20434176    34435.\n##  8 Spain            Europe     2007    80.9  40448191    28821.\n##  9 Sweden           Europe     2007    80.9   9031088    33860.\n## 10 Israel           Asia       2007    80.7   6426679    25523.\n## # ℹ 1,694 more rows\n```\n:::\n\n\nYou can sort by multiple columns by specifying them in a comma separated list. For example, we can sort by continent and then sort by life expectancy within the continents:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder %>% \n  arrange(continent, desc(lifeExp))\n## # A tibble: 1,704 × 6\n##    country   continent  year lifeExp      pop gdpPercap\n##    <fct>     <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Reunion   Africa     2007    76.4   798094     7670.\n##  2 Reunion   Africa     2002    75.7   743981     6316.\n##  3 Reunion   Africa     1997    74.8   684810     6072.\n##  4 Libya     Africa     2007    74.0  6036914    12057.\n##  5 Tunisia   Africa     2007    73.9 10276158     7093.\n##  6 Reunion   Africa     1992    73.6   622191     6101.\n##  7 Tunisia   Africa     2002    73.0  9770575     5723.\n##  8 Mauritius Africa     2007    72.8  1250882    10957.\n##  9 Libya     Africa     2002    72.7  5368585     9535.\n## 10 Algeria   Africa     2007    72.3 33333216     6223.\n## # ℹ 1,694 more rows\n```\n:::\n\n\n### That's it!\n\nThose are the main verbs you'll deal with in this class. There are dozens of other really useful ones—check out the [{dplyr} and {tidyr} cheat sheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) for examples. \n\n\n## Changing colors, shapes, and sizes, with `scale_*()`\n\nRecall from session 3 that the grammar of graphics uses a set of layers to define elements of plots:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](../../../../../slides/img/03/ggplot-layers@4x.png){fig-align='center' width=50%}\n:::\n:::\n\n\nIn tomorrow's session, you'll learn all about the Theme layer. Here we'll briefly cover the Scales layer, which we use for changing aspects of the different aesthetics, like using logged axes or changing colors or shapes.\n\nAll the functions that deal with scales conveniently follow the same naming pattern: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_AESTHETIC_DETAILS()\n```\n:::\n\n\nHere are some common scale functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_x_continuous()\nscale_y_reverse()\nscale_color_viridis_c()\nscale_shape_manual(values = c(19, 13, 15))\nscale_fill_manual(values = c(\"red\", \"orange\", \"blue\"))\n```\n:::\n\n\nYou can see a [list of all of the possible scale functions here](https://ggplot2.tidyverse.org/reference/index.html#section-scales), and you should reference that documentation (and the excellent examples) often when working with these functions.\n\nAs long as you have mapped a variable to an aesthetic with `aes()`, you can use the `scale_*()` functions to deal with it. For instance, in this ggplot, we have mapped variables to `x`, `y`, and `fill`, which means we can use those corresponding scale functions to manipulate how those aesthetics are shown. Here we reverse the y-axis (ew, don't really do this), and we use a discrete viridis color palette:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontinent_counts <- gapminder %>% \n  group_by(continent) %>% \n  summarize(countries = n_distinct(country))\n\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_y_reverse() +  # lol this is bad; don't do it in real life\n  scale_fill_viridis_d()\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-continent-counts-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nYou can also use different arguments in the scale functions—again, check the documentation for examples. For instance, if we want to use the [plasma palette from the viridis package](https://ggplot2.tidyverse.org/reference/scale_viridis.html), we can set that as an option:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_viridis_d(option = \"plasma\")\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-continent-plasma-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nThat yellow might be too bright and hard to see, so we can tell ggplot to not use the full range of the palette, ending at 90% of the range instead:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_viridis_d(option = \"plasma\", end = 0.9)\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-continent-plasma-9-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nInstead of letting R calculate the colors from a general palette, you can also specify your own colors with `scale_fill_manual()` and feeding it a list of values—generally as [hex codes](https://www.google.com/search?q=color+picker) or a name from a [list of built-in R colors](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\"))\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-continent-manual-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nScale functions also work for other aesthetics like `shape` or `color` or `size`. For instance, consider this plot, which has all three:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngapminder_2007 <- gapminder %>% \n  filter(year == 2007)\n\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10()\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-health-wealth-basic-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nWe can change the colors of the points with `scale_color_*()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\"))\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-health-wealth-colors-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nWe can change the shapes with `scale_shape_*()`. If you run `?pch` in your console or search for `pch` in the help, you can see all the possible shapes.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_shape_manual(values = c(12, 9, 17, 19, 15))\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-health-wealth-shapes-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nYou can change the size with `scale_size_*()`. Here we make it so the smallest possible size is 1 and the largest is 15:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_size_continuous(range = c(1, 15))\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-health-wealth-size-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nWe can even do all three at once:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\")) +\n  scale_shape_manual(values = c(12, 9, 17, 19, 15)) +\n  scale_size_continuous(range = c(1, 15))\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-health-wealth-everything-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nPhew. That's ugly.\n\nOne last thing we can do with scales is format how they show up on the plot. Notice how the population legend uses scientific notation like `2.50e+08`. This means you need to move the decimal point 8 places to the right, making it `250000000`. Leaving it in scientific notation isn't great because it makes it really hard to read and interpret.\n\nIf you load the {scales} library (which is installed as part of {tidyverse} but isn't automatically loaded), you can use some neat helper functions to reformat the text that shows up in plots. For instance, we can make it so population is formatted as a number with commas every 3 numbers, and the x-axis is formatted as dollars:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(scales)\n\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10(labels = label_dollar()) +\n  scale_size_continuous(labels = label_comma())\n```\n\n::: {.cell-output-display}\n![](04-lesson_files/figure-html/plot-health-wealth-scale-labels-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n[Check the documentation for {scales}](https://scales.r-lib.org/reference/index.html) for details about all the labelling functions it has, including dates, percentages, p-values, LaTeX math, etc.\n",
    "supporting": [
      "04-lesson_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}