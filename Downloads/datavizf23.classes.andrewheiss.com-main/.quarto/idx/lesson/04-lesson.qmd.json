{"title":"Amounts and proportions","markdown":{"yaml":{"title":"Amounts and proportions","date":"2023-09-11","date_end":"2023-09-15"},"headingText":"Manipulating data with","headingAttr":{"id":"","classes":[],"keyvalue":[["dplyr",""]]},"containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nlibrary(gapminder)\n\nknitr::opts_chunk$set(fig.width = 6, fig.height = 4.5, fig.align = \"center\", collapse = TRUE)\nset.seed(1234)\noptions(dplyr.summarise.inform = FALSE)\n```\n\n```{r learnr-setup, echo=FALSE, results=\"asis\"}\nsource(here::here(\"R\", \"learnr-things.R\"))\ninclude_iframe_resizer()\n```\n\nWhen you visualize proportions with ggplot, you'll typically go through a two-step process:\n\n1. Summarize the data with {dplyr} (typically with a combination of  `group_by()` and `summarize()`)\n2. Plot the summarized data\n\n\n\nYou had some experience with {dplyr} functions in the RStudio primers, but we'll briefly review them here.\n\nThere are 6 important verbs that you'll typically use when working with data:\n\n- Extract rows/cases with `filter()`\n- Extract columns/variables with `select()`\n- Arrange/sort rows with `arrange()`\n- Make new columns/variables with `mutate()`\n- Make group summaries with `group_by %>% summarize()`\n\nEvery {dplyr} verb follows the same pattern. The first argument is always a data frame, and the function always returns a data frame:\n\n```{r dplyr-template, eval=FALSE}\nVERB(DATA_TO_TRANSFORM, STUFF_IT_DOES)\n```\n\n### Filtering with `filter()`\n\nThe `filter()` function takes two arguments: a data frame to transform, and a set of tests. It will return each row for which the test is TRUE.\n\nThis code, for instance, will look at the `gapminder` dataset and return all rows where `country` is equal to \"Denmark\":\n\n```{r filter-denmark}\nfilter(gapminder, country == \"Denmark\")\n```\n\nNotice that there are two equal signs (`==`). This is because it's a logical test, similar to greater than (`>`) or less than (`<`). When you use a single equal sign, you set an argument (like `data = gapminder`); when you use two, you are doing a test. There are lots of different ways to do logical tests:\n\n| Test        | Meaning                  |\n| ----------- | ------------------------ |\n| `x < y`     | Less than                |\n| `x > y`     | Greater than             |\n| `x == y`    | Equal to                 |\n| `x <= y`    | Less than or equal to    |\n| `x >= y`    | Greater than or equal to |\n| `x != y`    | Not equal to             |\n| `x %in% y`  | In (group membership)    |\n| `is.na(x)`  | Is missing               |\n| `!is.na(x)` | Is not missing           |\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and logical tests to show:\n\n1. The data for Canada\n2. All data for countries in Oceania\n3. Rows where life expectancy is greater than 82\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-1/\",\n  id = \"learnr-04-lesson-dplyr1\"\n)\n```\n\nYou can also use multiple conditions, and these will extract rows that meet every test. By default, if you separate the tests with a comma, R will consider this an \"and\" test and find rows that are *both* Denmark and greater than 2000.\n\n```{r filter-denmark-multiple}\nfilter(gapminder, country == \"Denmark\", year > 2000)\n```\n\nYou can also use \"or\" with \"`|`\" and \"not\" with \"`!`\":\n\n| Operator | Meaning |\n| -------- | ------- |\n| `a & b`  | and     |\n| `a | b`  | or      |\n| `!a`     | not     |\n\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and logical tests to show:\n\n1. Canada before 1970\n2. Countries where life expectancy in 2007 is below 50\n3. Countries where life expectancy in 2007 is below 50 and are not in Africa\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-2/\",\n  id = \"learnr-04-lesson-dplyr2\"\n)\n```\n\nBeware of some common mistakes! You can't collapse multiple tests into one. Instead, use two separate tests:\n\n```{r filter-multiple, eval=FALSE}\n# This won't work!\nfilter(gapminder, 1960 < year < 1980)\n\n# This will work\nfilter(gapminder, 1960 < year, year < 1980)\n```\n\nAlso, you can avoid stringing together lots of tests by using the `%in%` operator, which checks to see if a value is in a list of values.\n\n```{r filter-in, eval=FALSE}\n# This works, but is tedious\nfilter(gapminder, \n       country == \"Mexico\" | country == \"Canada\" | country == \"United States\")\n\n# This is more concise and easier to add other countries later\nfilter(gapminder, \n       country %in% c(\"Mexico\", \"Canada\", \"United States\"))\n```\n\n### Adding new columns with `mutate()`\n\nYou create new columns with the `mutate()` function. You can create a single column like this:\n\n```{r mutate-single}\nmutate(gapminder, gdp = gdpPercap * pop)\n```\n\nAnd you can create multiple columns by including a comma-separated list of new columns to create:\n\n```{r mutate-multiple}\nmutate(gapminder, gdp = gdpPercap * pop,\n                  pop_mill = round(pop / 1000000))\n```\n\nYou can also do conditional tests within `mutate()` using the `ifelse()` function. This works like the `=IFELSE` function in Excel. Feed the function three arguments: (1) a test, (2) the value if the test is true, and (3) the value if the test is false:\n\n```{r show-ifelse, eval=FALSE}\nifelse(TEST, VALUE_IF_TRUE, VALUE_IF_FALSE)\n```\n\nWe can create a new column that is a binary indicator for whether the country's row is after 1960:\n\n```{r mutate-after-1960}\nmutate(gapminder, after_1960 = ifelse(year > 1960, TRUE, FALSE))\n```\n\nWe can also use text labels instead of `TRUE` and `FALSE`:\n\n```{r mutate-after-1960-text}\nmutate(gapminder, \n       after_1960 = ifelse(year > 1960, \"After 1960\", \"Before 1960\"))\n```\n\n::: {.callout-important}\n### Your turn\n\nUse `mutate()` to:\n\n1. Add an `africa` column that is TRUE if the country is on the African continent\n2. Add a column for logged GDP per capita\n3. Add an `africa_asia` column that says “Africa or Asia” if the country is in Africa or Asia, and “Not Africa or Asia” if it’s not\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-3/\",\n  id = \"learnr-04-lesson-dplyr3\"\n)\n```\n\n### Combining multiple verbs with pipes (`%>%`)\n\nWhat if you want to filter to include only rows from 2002 *and* make a new column with the logged GDP per capita? Doing this requires both `filter()` and `mutate()`, so we need to find a way to use both at once.\n\nOne solution is to use intermediate variables for each step:\n\n```{r pipes-intermediate, eval=FALSE}\ngapminder_2002_filtered <- filter(gapminder, year == 2002)\n\ngapminder_2002_logged <- mutate(gapminder_2002_filtered, log_gdpPercap = log(gdpPercap))\n```\n\nThat works fine, but your environment panel will start getting full of lots of intermediate data frames.\n\nAnother solution is to nest the functions inside each other. Remember that all {dplyr} functions return data frames, so you can feed the results of one into another:\n\n```{r pipes-nested, eval=FALSE}\nfilter(mutate(gapminder, log_gdpPercap = log(gdpPercap)), \n       year == 2002)\n```\n\nThat works too, but it gets *really* complicated once you have even more functions, and it's hard to keep track of which function's arguments go where. I'd avoid doing this entirely.\n\nOne really nice solution is to use a pipe, or `%>%`. **The pipe takes an object on the left and passes it as the first argument of the function on the right**.\n\n```{r pipe-example, eval=FALSE}\n# gapminder will automatically get placed in the _____ spot\ngapminder %>% filter(_____, country == \"Canada\")\n```\n\nThese two lines of code do the same thing:\n\n```{r pipe-equivalent, eval=FALSE}\nfilter(gapminder, country == \"Canada\")\n\ngapminder %>% filter(country == \"Canada\")\n```\n\nUsing pipes, you can start with a data frame, pass it to one verb, then pass the output of that verb to the next verb, and so on. **When reading any code with a `%>%`, it's easiest to read the `%>%` as \"and then\".** This would read:\n\n> Take the `gapminder` dataset *and then* filter it so that it only has rows from 2002 *and then* add a new column with the logged GDP per capita\n\n```{r pipes-full-example, eval=FALSE}\ngapminder %>% \n  filter(year == 2002) %>% \n  mutate(log_gdpPercap = log(gdpPercap))\n```\n\nHere's another way to think about pipes more conceptually. This isn't valid R code, obviously, but imagine you're going to take yourself, and then wake up, get out of bed, get dressed, and leave the house. Writing that whole process as nested functions would look like this:\n\n```{r wake-up-nested, eval=FALSE}\nleave_house(get_dressed(get_out_of_bed(wake_up(me, time = \"8:00\"), side = \"correct\"), pants = TRUE, shirt = TRUE), car = TRUE, bike = FALSE)\n```\n\nInstead of nesting everything, we can use pipes to chain these together. This would read\n\n> Take myself, *and then* wake up at 8:00, *and then* get out of bed on the correct side, *and then* get dressed with pants and a shirt, *and then* leave the house in a car\n\n```{r wake-up-pipes, eval=FALSE}\nme %>% \n  wake_up(time = \"8:00\") %>% \n  get_out_of_bed(side = \"correct\") %>% \n  get_dressed(pants = TRUE, shirt = TRUE) %>% \n  leave_house(car = TRUE, bike = FALSE)\n```\n\n### Summarizing data by groups with `group_by() %>% summarize()`\n\nThe `summarize()` verb takes an entire frame and calculates summary information about it. For instance, this will find the average life expectancy for the whole `gapminder` data:\n\n```{r summarize-full-single}\ngapminder %>% summarize(mean_life = mean(lifeExp))\n```\n\nYou can also make multiple summary variables, just like `mutate()`, and it will return a column for each:\n\n```{r summarize-full-multiple}\ngapminder %>% summarize(mean_life = mean(lifeExp),\n                        min_life = min(lifeExp))\n```\n\n::: {.callout-important}\n### Your turn\n\nUse `summarize()` to calculate:\n\n1. The first (minimum) year in the `gapminder` dataset\n2. The last (maximum) year in the dataset\n3. The number of rows in the dataset (use the [{dplyr} cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))\n4. The number of distinct countries in the dataset (use the [{dplyr} cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-4/\",\n  id = \"learnr-04-lesson-dplyr4\"\n)\n```\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and `summarize()` to calculate the median life expectancy on the African continent in 2007:\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-5/\",\n  id = \"learnr-04-lesson-dplyr5\"\n)\n```\n\nNotice that `summarize()` on its own summarizes the whole dataset, so you only get a single row back. These values are the averages and minimums for the entire data frame. If you group your data into separate subgroups, you can use `summarize()` to calculate summary statistics for each group. Do this with `group_by()`.\n\nThe `group_by()` function puts rows into groups based on values in a column. If you run this:\n\n```{r summarize-groupby}\ngapminder %>% group_by(continent)\n```\n\n…you won't see anything different! R has put the dataset into separate invisible groups behind the scenes, but you haven't done anything with those groups, so nothing has really happened. If you do things with those groups with `summarize()`, though, `group_by()` becomes much more useful.\n\nFor instance, this will take the `gapminder` data frame, group it by continent, and then summarize it by calculating the number of distinct countries in each group. It will return *one row for each group*, so there should be a row for each continent:\n\n```{r summarize-group-distinct}\ngapminder %>% \n  group_by(continent) %>% \n  summarize(n_countries = n_distinct(country)) \n```\n\nYou can calculate multiple summary statistics, as before:\n\n```{r summarize-group-distinct-multiple}\ngapminder %>% \n  group_by(continent) %>% \n  summarize(n_countries = n_distinct(country),\n            avg_life_exp = mean(lifeExp)) \n```\n\n::: {.callout-important}\n### Your turn\n\nFind the minimum, maximum, and median life expectancy for each continent:\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-6/\",\n  id = \"learnr-04-lesson-dplyr6\"\n)\n```\n\n::: {.callout-important}\n### Your turn\n\nFind the minimum, maximum, and median life expectancy for each continent in 2007 only:\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-7/\",\n  id = \"learnr-04-lesson-dplyr7\"\n)\n```\n\nFinally, you can group by multiple columns and R will create subgroups for every combination of the groups and return the number of rows of combinations. For instance, we can calculate the average life expectancy by both year and continent and we'll get 60 rows, since there are 5 continents and 12 years (5 × 12 = 60):\n\n```{r groupby-year-continent}\ngapminder %>% \n  group_by(continent, year) %>% \n  summarize(avg_life_exp = mean(lifeExp)) \n```\n\n\n### Selecting with `select()`\n\nThe last two verbs are far simpler than `filter()`, `mutate()`, and `group_by() %>% summarize()`.\n\nYou can choose specific columns with the `select()` verb. This will only keep two columns: `lifeExp` and `year`:\n\n```{r select-single}\ngapminder %>% select(lifeExp, year)\n```\n\nYou can remove specific columns by prefacing the column names with `-`, like `-lifeExp`:\n\n```{r omit-single}\ngapminder %>% select(-lifeExp)\n```\n\nYou can also rename columns using `select()`. Follow this pattern: `select(old_name = new_name)`.\n\n```{r rename-select}\ngapminder %>% select(year, country, life_expectancy = lifeExp)\n```\n\nAlternatively, there's a special `rename()` verb that will, um, rename, while keeping all the other columns:\n\n```{r rename-rename}\ngapminder %>% rename(life_expectancy = lifeExp)\n```\n\n### Arranging data with `arrange()`\n\nThe `arrange()` verb sorts data. By default it sorts ascendingly, putting the lowest values first:\n\n```{r arrange-single}\ngapminder %>% arrange(lifeExp)\n```\n\nYou can reverse that by wrapping the column name with `desc()`:\n\n```{r arrange-single-desc}\ngapminder %>% arrange(desc(lifeExp))\n```\n\nYou can sort by multiple columns by specifying them in a comma separated list. For example, we can sort by continent and then sort by life expectancy within the continents:\n\n```{r arrange-multiple}\ngapminder %>% \n  arrange(continent, desc(lifeExp))\n```\n\n### That's it!\n\nThose are the main verbs you'll deal with in this class. There are dozens of other really useful ones—check out the [{dplyr} and {tidyr} cheat sheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) for examples. \n\n\n## Changing colors, shapes, and sizes, with `scale_*()`\n\nRecall from session 3 that the grammar of graphics uses a set of layers to define elements of plots:\n\n```{r gg-layers, echo=FALSE, out.width=\"50%\", fig.align=\"center\"}\nknitr::include_graphics(\"/slides/img/03/ggplot-layers@4x.png\", error = FALSE)\n```\n\nIn tomorrow's session, you'll learn all about the Theme layer. Here we'll briefly cover the Scales layer, which we use for changing aspects of the different aesthetics, like using logged axes or changing colors or shapes.\n\nAll the functions that deal with scales conveniently follow the same naming pattern: \n\n```{r scale-template, eval=FALSE}\nscale_AESTHETIC_DETAILS()\n```\n\nHere are some common scale functions:\n\n```{r scale-examples, eval=FALSE}\nscale_x_continuous()\nscale_y_reverse()\nscale_color_viridis_c()\nscale_shape_manual(values = c(19, 13, 15))\nscale_fill_manual(values = c(\"red\", \"orange\", \"blue\"))\n```\n\nYou can see a [list of all of the possible scale functions here](https://ggplot2.tidyverse.org/reference/index.html#section-scales), and you should reference that documentation (and the excellent examples) often when working with these functions.\n\nAs long as you have mapped a variable to an aesthetic with `aes()`, you can use the `scale_*()` functions to deal with it. For instance, in this ggplot, we have mapped variables to `x`, `y`, and `fill`, which means we can use those corresponding scale functions to manipulate how those aesthetics are shown. Here we reverse the y-axis (ew, don't really do this), and we use a discrete viridis color palette:\n\n```{r plot-continent-counts}\ncontinent_counts <- gapminder %>% \n  group_by(continent) %>% \n  summarize(countries = n_distinct(country))\n\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_y_reverse() +  # lol this is bad; don't do it in real life\n  scale_fill_viridis_d()\n```\n\nYou can also use different arguments in the scale functions—again, check the documentation for examples. For instance, if we want to use the [plasma palette from the viridis package](https://ggplot2.tidyverse.org/reference/scale_viridis.html), we can set that as an option:\n\n```{r plot-continent-plasma}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_viridis_d(option = \"plasma\")\n```\n\nThat yellow might be too bright and hard to see, so we can tell ggplot to not use the full range of the palette, ending at 90% of the range instead:\n\n```{r plot-continent-plasma-9}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_viridis_d(option = \"plasma\", end = 0.9)\n```\n\nInstead of letting R calculate the colors from a general palette, you can also specify your own colors with `scale_fill_manual()` and feeding it a list of values—generally as [hex codes](https://www.google.com/search?q=color+picker) or a name from a [list of built-in R colors](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf):\n\n```{r plot-continent-manual}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\"))\n```\n\nScale functions also work for other aesthetics like `shape` or `color` or `size`. For instance, consider this plot, which has all three:\n\n```{r plot-health-wealth-basic}\ngapminder_2007 <- gapminder %>% \n  filter(year == 2007)\n\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10()\n```\n\nWe can change the colors of the points with `scale_color_*()`:\n\n```{r plot-health-wealth-colors}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\"))\n```\n\nWe can change the shapes with `scale_shape_*()`. If you run `?pch` in your console or search for `pch` in the help, you can see all the possible shapes.\n\n```{r plot-health-wealth-shapes}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_shape_manual(values = c(12, 9, 17, 19, 15))\n```\n\nYou can change the size with `scale_size_*()`. Here we make it so the smallest possible size is 1 and the largest is 15:\n\n```{r plot-health-wealth-size}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_size_continuous(range = c(1, 15))\n```\n\nWe can even do all three at once:\n\n```{r plot-health-wealth-everything}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\")) +\n  scale_shape_manual(values = c(12, 9, 17, 19, 15)) +\n  scale_size_continuous(range = c(1, 15))\n```\n\nPhew. That's ugly.\n\nOne last thing we can do with scales is format how they show up on the plot. Notice how the population legend uses scientific notation like `2.50e+08`. This means you need to move the decimal point 8 places to the right, making it `250000000`. Leaving it in scientific notation isn't great because it makes it really hard to read and interpret.\n\nIf you load the {scales} library (which is installed as part of {tidyverse} but isn't automatically loaded), you can use some neat helper functions to reformat the text that shows up in plots. For instance, we can make it so population is formatted as a number with commas every 3 numbers, and the x-axis is formatted as dollars:\n\n```{r plot-health-wealth-scale-labels, warning=FALSE, message=FALSE}\nlibrary(scales)\n\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10(labels = label_dollar()) +\n  scale_size_continuous(labels = label_comma())\n```\n\n[Check the documentation for {scales}](https://scales.r-lib.org/reference/index.html) for details about all the labelling functions it has, including dates, percentages, p-values, LaTeX math, etc.\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nlibrary(gapminder)\n\nknitr::opts_chunk$set(fig.width = 6, fig.height = 4.5, fig.align = \"center\", collapse = TRUE)\nset.seed(1234)\noptions(dplyr.summarise.inform = FALSE)\n```\n\n```{r learnr-setup, echo=FALSE, results=\"asis\"}\nsource(here::here(\"R\", \"learnr-things.R\"))\ninclude_iframe_resizer()\n```\n\nWhen you visualize proportions with ggplot, you'll typically go through a two-step process:\n\n1. Summarize the data with {dplyr} (typically with a combination of  `group_by()` and `summarize()`)\n2. Plot the summarized data\n\n\n## Manipulating data with {dplyr}\n\nYou had some experience with {dplyr} functions in the RStudio primers, but we'll briefly review them here.\n\nThere are 6 important verbs that you'll typically use when working with data:\n\n- Extract rows/cases with `filter()`\n- Extract columns/variables with `select()`\n- Arrange/sort rows with `arrange()`\n- Make new columns/variables with `mutate()`\n- Make group summaries with `group_by %>% summarize()`\n\nEvery {dplyr} verb follows the same pattern. The first argument is always a data frame, and the function always returns a data frame:\n\n```{r dplyr-template, eval=FALSE}\nVERB(DATA_TO_TRANSFORM, STUFF_IT_DOES)\n```\n\n### Filtering with `filter()`\n\nThe `filter()` function takes two arguments: a data frame to transform, and a set of tests. It will return each row for which the test is TRUE.\n\nThis code, for instance, will look at the `gapminder` dataset and return all rows where `country` is equal to \"Denmark\":\n\n```{r filter-denmark}\nfilter(gapminder, country == \"Denmark\")\n```\n\nNotice that there are two equal signs (`==`). This is because it's a logical test, similar to greater than (`>`) or less than (`<`). When you use a single equal sign, you set an argument (like `data = gapminder`); when you use two, you are doing a test. There are lots of different ways to do logical tests:\n\n| Test        | Meaning                  |\n| ----------- | ------------------------ |\n| `x < y`     | Less than                |\n| `x > y`     | Greater than             |\n| `x == y`    | Equal to                 |\n| `x <= y`    | Less than or equal to    |\n| `x >= y`    | Greater than or equal to |\n| `x != y`    | Not equal to             |\n| `x %in% y`  | In (group membership)    |\n| `is.na(x)`  | Is missing               |\n| `!is.na(x)` | Is not missing           |\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and logical tests to show:\n\n1. The data for Canada\n2. All data for countries in Oceania\n3. Rows where life expectancy is greater than 82\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-1/\",\n  id = \"learnr-04-lesson-dplyr1\"\n)\n```\n\nYou can also use multiple conditions, and these will extract rows that meet every test. By default, if you separate the tests with a comma, R will consider this an \"and\" test and find rows that are *both* Denmark and greater than 2000.\n\n```{r filter-denmark-multiple}\nfilter(gapminder, country == \"Denmark\", year > 2000)\n```\n\nYou can also use \"or\" with \"`|`\" and \"not\" with \"`!`\":\n\n| Operator | Meaning |\n| -------- | ------- |\n| `a & b`  | and     |\n| `a | b`  | or      |\n| `!a`     | not     |\n\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and logical tests to show:\n\n1. Canada before 1970\n2. Countries where life expectancy in 2007 is below 50\n3. Countries where life expectancy in 2007 is below 50 and are not in Africa\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-2/\",\n  id = \"learnr-04-lesson-dplyr2\"\n)\n```\n\nBeware of some common mistakes! You can't collapse multiple tests into one. Instead, use two separate tests:\n\n```{r filter-multiple, eval=FALSE}\n# This won't work!\nfilter(gapminder, 1960 < year < 1980)\n\n# This will work\nfilter(gapminder, 1960 < year, year < 1980)\n```\n\nAlso, you can avoid stringing together lots of tests by using the `%in%` operator, which checks to see if a value is in a list of values.\n\n```{r filter-in, eval=FALSE}\n# This works, but is tedious\nfilter(gapminder, \n       country == \"Mexico\" | country == \"Canada\" | country == \"United States\")\n\n# This is more concise and easier to add other countries later\nfilter(gapminder, \n       country %in% c(\"Mexico\", \"Canada\", \"United States\"))\n```\n\n### Adding new columns with `mutate()`\n\nYou create new columns with the `mutate()` function. You can create a single column like this:\n\n```{r mutate-single}\nmutate(gapminder, gdp = gdpPercap * pop)\n```\n\nAnd you can create multiple columns by including a comma-separated list of new columns to create:\n\n```{r mutate-multiple}\nmutate(gapminder, gdp = gdpPercap * pop,\n                  pop_mill = round(pop / 1000000))\n```\n\nYou can also do conditional tests within `mutate()` using the `ifelse()` function. This works like the `=IFELSE` function in Excel. Feed the function three arguments: (1) a test, (2) the value if the test is true, and (3) the value if the test is false:\n\n```{r show-ifelse, eval=FALSE}\nifelse(TEST, VALUE_IF_TRUE, VALUE_IF_FALSE)\n```\n\nWe can create a new column that is a binary indicator for whether the country's row is after 1960:\n\n```{r mutate-after-1960}\nmutate(gapminder, after_1960 = ifelse(year > 1960, TRUE, FALSE))\n```\n\nWe can also use text labels instead of `TRUE` and `FALSE`:\n\n```{r mutate-after-1960-text}\nmutate(gapminder, \n       after_1960 = ifelse(year > 1960, \"After 1960\", \"Before 1960\"))\n```\n\n::: {.callout-important}\n### Your turn\n\nUse `mutate()` to:\n\n1. Add an `africa` column that is TRUE if the country is on the African continent\n2. Add a column for logged GDP per capita\n3. Add an `africa_asia` column that says “Africa or Asia” if the country is in Africa or Asia, and “Not Africa or Asia” if it’s not\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-3/\",\n  id = \"learnr-04-lesson-dplyr3\"\n)\n```\n\n### Combining multiple verbs with pipes (`%>%`)\n\nWhat if you want to filter to include only rows from 2002 *and* make a new column with the logged GDP per capita? Doing this requires both `filter()` and `mutate()`, so we need to find a way to use both at once.\n\nOne solution is to use intermediate variables for each step:\n\n```{r pipes-intermediate, eval=FALSE}\ngapminder_2002_filtered <- filter(gapminder, year == 2002)\n\ngapminder_2002_logged <- mutate(gapminder_2002_filtered, log_gdpPercap = log(gdpPercap))\n```\n\nThat works fine, but your environment panel will start getting full of lots of intermediate data frames.\n\nAnother solution is to nest the functions inside each other. Remember that all {dplyr} functions return data frames, so you can feed the results of one into another:\n\n```{r pipes-nested, eval=FALSE}\nfilter(mutate(gapminder, log_gdpPercap = log(gdpPercap)), \n       year == 2002)\n```\n\nThat works too, but it gets *really* complicated once you have even more functions, and it's hard to keep track of which function's arguments go where. I'd avoid doing this entirely.\n\nOne really nice solution is to use a pipe, or `%>%`. **The pipe takes an object on the left and passes it as the first argument of the function on the right**.\n\n```{r pipe-example, eval=FALSE}\n# gapminder will automatically get placed in the _____ spot\ngapminder %>% filter(_____, country == \"Canada\")\n```\n\nThese two lines of code do the same thing:\n\n```{r pipe-equivalent, eval=FALSE}\nfilter(gapminder, country == \"Canada\")\n\ngapminder %>% filter(country == \"Canada\")\n```\n\nUsing pipes, you can start with a data frame, pass it to one verb, then pass the output of that verb to the next verb, and so on. **When reading any code with a `%>%`, it's easiest to read the `%>%` as \"and then\".** This would read:\n\n> Take the `gapminder` dataset *and then* filter it so that it only has rows from 2002 *and then* add a new column with the logged GDP per capita\n\n```{r pipes-full-example, eval=FALSE}\ngapminder %>% \n  filter(year == 2002) %>% \n  mutate(log_gdpPercap = log(gdpPercap))\n```\n\nHere's another way to think about pipes more conceptually. This isn't valid R code, obviously, but imagine you're going to take yourself, and then wake up, get out of bed, get dressed, and leave the house. Writing that whole process as nested functions would look like this:\n\n```{r wake-up-nested, eval=FALSE}\nleave_house(get_dressed(get_out_of_bed(wake_up(me, time = \"8:00\"), side = \"correct\"), pants = TRUE, shirt = TRUE), car = TRUE, bike = FALSE)\n```\n\nInstead of nesting everything, we can use pipes to chain these together. This would read\n\n> Take myself, *and then* wake up at 8:00, *and then* get out of bed on the correct side, *and then* get dressed with pants and a shirt, *and then* leave the house in a car\n\n```{r wake-up-pipes, eval=FALSE}\nme %>% \n  wake_up(time = \"8:00\") %>% \n  get_out_of_bed(side = \"correct\") %>% \n  get_dressed(pants = TRUE, shirt = TRUE) %>% \n  leave_house(car = TRUE, bike = FALSE)\n```\n\n### Summarizing data by groups with `group_by() %>% summarize()`\n\nThe `summarize()` verb takes an entire frame and calculates summary information about it. For instance, this will find the average life expectancy for the whole `gapminder` data:\n\n```{r summarize-full-single}\ngapminder %>% summarize(mean_life = mean(lifeExp))\n```\n\nYou can also make multiple summary variables, just like `mutate()`, and it will return a column for each:\n\n```{r summarize-full-multiple}\ngapminder %>% summarize(mean_life = mean(lifeExp),\n                        min_life = min(lifeExp))\n```\n\n::: {.callout-important}\n### Your turn\n\nUse `summarize()` to calculate:\n\n1. The first (minimum) year in the `gapminder` dataset\n2. The last (maximum) year in the dataset\n3. The number of rows in the dataset (use the [{dplyr} cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))\n4. The number of distinct countries in the dataset (use the [{dplyr} cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-4/\",\n  id = \"learnr-04-lesson-dplyr4\"\n)\n```\n\n::: {.callout-important}\n### Your turn\n\nUse `filter()` and `summarize()` to calculate the median life expectancy on the African continent in 2007:\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-5/\",\n  id = \"learnr-04-lesson-dplyr5\"\n)\n```\n\nNotice that `summarize()` on its own summarizes the whole dataset, so you only get a single row back. These values are the averages and minimums for the entire data frame. If you group your data into separate subgroups, you can use `summarize()` to calculate summary statistics for each group. Do this with `group_by()`.\n\nThe `group_by()` function puts rows into groups based on values in a column. If you run this:\n\n```{r summarize-groupby}\ngapminder %>% group_by(continent)\n```\n\n…you won't see anything different! R has put the dataset into separate invisible groups behind the scenes, but you haven't done anything with those groups, so nothing has really happened. If you do things with those groups with `summarize()`, though, `group_by()` becomes much more useful.\n\nFor instance, this will take the `gapminder` data frame, group it by continent, and then summarize it by calculating the number of distinct countries in each group. It will return *one row for each group*, so there should be a row for each continent:\n\n```{r summarize-group-distinct}\ngapminder %>% \n  group_by(continent) %>% \n  summarize(n_countries = n_distinct(country)) \n```\n\nYou can calculate multiple summary statistics, as before:\n\n```{r summarize-group-distinct-multiple}\ngapminder %>% \n  group_by(continent) %>% \n  summarize(n_countries = n_distinct(country),\n            avg_life_exp = mean(lifeExp)) \n```\n\n::: {.callout-important}\n### Your turn\n\nFind the minimum, maximum, and median life expectancy for each continent:\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-6/\",\n  id = \"learnr-04-lesson-dplyr6\"\n)\n```\n\n::: {.callout-important}\n### Your turn\n\nFind the minimum, maximum, and median life expectancy for each continent in 2007 only:\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_04-dplyr-7/\",\n  id = \"learnr-04-lesson-dplyr7\"\n)\n```\n\nFinally, you can group by multiple columns and R will create subgroups for every combination of the groups and return the number of rows of combinations. For instance, we can calculate the average life expectancy by both year and continent and we'll get 60 rows, since there are 5 continents and 12 years (5 × 12 = 60):\n\n```{r groupby-year-continent}\ngapminder %>% \n  group_by(continent, year) %>% \n  summarize(avg_life_exp = mean(lifeExp)) \n```\n\n\n### Selecting with `select()`\n\nThe last two verbs are far simpler than `filter()`, `mutate()`, and `group_by() %>% summarize()`.\n\nYou can choose specific columns with the `select()` verb. This will only keep two columns: `lifeExp` and `year`:\n\n```{r select-single}\ngapminder %>% select(lifeExp, year)\n```\n\nYou can remove specific columns by prefacing the column names with `-`, like `-lifeExp`:\n\n```{r omit-single}\ngapminder %>% select(-lifeExp)\n```\n\nYou can also rename columns using `select()`. Follow this pattern: `select(old_name = new_name)`.\n\n```{r rename-select}\ngapminder %>% select(year, country, life_expectancy = lifeExp)\n```\n\nAlternatively, there's a special `rename()` verb that will, um, rename, while keeping all the other columns:\n\n```{r rename-rename}\ngapminder %>% rename(life_expectancy = lifeExp)\n```\n\n### Arranging data with `arrange()`\n\nThe `arrange()` verb sorts data. By default it sorts ascendingly, putting the lowest values first:\n\n```{r arrange-single}\ngapminder %>% arrange(lifeExp)\n```\n\nYou can reverse that by wrapping the column name with `desc()`:\n\n```{r arrange-single-desc}\ngapminder %>% arrange(desc(lifeExp))\n```\n\nYou can sort by multiple columns by specifying them in a comma separated list. For example, we can sort by continent and then sort by life expectancy within the continents:\n\n```{r arrange-multiple}\ngapminder %>% \n  arrange(continent, desc(lifeExp))\n```\n\n### That's it!\n\nThose are the main verbs you'll deal with in this class. There are dozens of other really useful ones—check out the [{dplyr} and {tidyr} cheat sheet](https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) for examples. \n\n\n## Changing colors, shapes, and sizes, with `scale_*()`\n\nRecall from session 3 that the grammar of graphics uses a set of layers to define elements of plots:\n\n```{r gg-layers, echo=FALSE, out.width=\"50%\", fig.align=\"center\"}\nknitr::include_graphics(\"/slides/img/03/ggplot-layers@4x.png\", error = FALSE)\n```\n\nIn tomorrow's session, you'll learn all about the Theme layer. Here we'll briefly cover the Scales layer, which we use for changing aspects of the different aesthetics, like using logged axes or changing colors or shapes.\n\nAll the functions that deal with scales conveniently follow the same naming pattern: \n\n```{r scale-template, eval=FALSE}\nscale_AESTHETIC_DETAILS()\n```\n\nHere are some common scale functions:\n\n```{r scale-examples, eval=FALSE}\nscale_x_continuous()\nscale_y_reverse()\nscale_color_viridis_c()\nscale_shape_manual(values = c(19, 13, 15))\nscale_fill_manual(values = c(\"red\", \"orange\", \"blue\"))\n```\n\nYou can see a [list of all of the possible scale functions here](https://ggplot2.tidyverse.org/reference/index.html#section-scales), and you should reference that documentation (and the excellent examples) often when working with these functions.\n\nAs long as you have mapped a variable to an aesthetic with `aes()`, you can use the `scale_*()` functions to deal with it. For instance, in this ggplot, we have mapped variables to `x`, `y`, and `fill`, which means we can use those corresponding scale functions to manipulate how those aesthetics are shown. Here we reverse the y-axis (ew, don't really do this), and we use a discrete viridis color palette:\n\n```{r plot-continent-counts}\ncontinent_counts <- gapminder %>% \n  group_by(continent) %>% \n  summarize(countries = n_distinct(country))\n\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_y_reverse() +  # lol this is bad; don't do it in real life\n  scale_fill_viridis_d()\n```\n\nYou can also use different arguments in the scale functions—again, check the documentation for examples. For instance, if we want to use the [plasma palette from the viridis package](https://ggplot2.tidyverse.org/reference/scale_viridis.html), we can set that as an option:\n\n```{r plot-continent-plasma}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_viridis_d(option = \"plasma\")\n```\n\nThat yellow might be too bright and hard to see, so we can tell ggplot to not use the full range of the palette, ending at 90% of the range instead:\n\n```{r plot-continent-plasma-9}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_viridis_d(option = \"plasma\", end = 0.9)\n```\n\nInstead of letting R calculate the colors from a general palette, you can also specify your own colors with `scale_fill_manual()` and feeding it a list of values—generally as [hex codes](https://www.google.com/search?q=color+picker) or a name from a [list of built-in R colors](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf):\n\n```{r plot-continent-manual}\nggplot(continent_counts, aes(x = continent, y = countries, fill = continent)) +\n  geom_col() +\n  scale_fill_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\"))\n```\n\nScale functions also work for other aesthetics like `shape` or `color` or `size`. For instance, consider this plot, which has all three:\n\n```{r plot-health-wealth-basic}\ngapminder_2007 <- gapminder %>% \n  filter(year == 2007)\n\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10()\n```\n\nWe can change the colors of the points with `scale_color_*()`:\n\n```{r plot-health-wealth-colors}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\"))\n```\n\nWe can change the shapes with `scale_shape_*()`. If you run `?pch` in your console or search for `pch` in the help, you can see all the possible shapes.\n\n```{r plot-health-wealth-shapes}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_shape_manual(values = c(12, 9, 17, 19, 15))\n```\n\nYou can change the size with `scale_size_*()`. Here we make it so the smallest possible size is 1 and the largest is 15:\n\n```{r plot-health-wealth-size}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_size_continuous(range = c(1, 15))\n```\n\nWe can even do all three at once:\n\n```{r plot-health-wealth-everything}\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"chartreuse4\", \"cornsilk4\", \"black\", \"#fc03b6\", \"#5c47d6\")) +\n  scale_shape_manual(values = c(12, 9, 17, 19, 15)) +\n  scale_size_continuous(range = c(1, 15))\n```\n\nPhew. That's ugly.\n\nOne last thing we can do with scales is format how they show up on the plot. Notice how the population legend uses scientific notation like `2.50e+08`. This means you need to move the decimal point 8 places to the right, making it `250000000`. Leaving it in scientific notation isn't great because it makes it really hard to read and interpret.\n\nIf you load the {scales} library (which is installed as part of {tidyverse} but isn't automatically loaded), you can use some neat helper functions to reformat the text that shows up in plots. For instance, we can make it so population is formatted as a number with commas every 3 numbers, and the x-axis is formatted as dollars:\n\n```{r plot-health-wealth-scale-labels, warning=FALSE, message=FALSE}\nlibrary(scales)\n\nggplot(gapminder_2007,\n       aes(x = gdpPercap, y = lifeExp, \n           color = continent, shape = continent, size = pop)) +\n  geom_point() +\n  scale_x_log10(labels = label_dollar()) +\n  scale_size_continuous(labels = label_comma())\n```\n\n[Check the documentation for {scales}](https://scales.r-lib.org/reference/index.html) for details about all the labelling functions it has, including dates, percentages, p-values, LaTeX math, etc.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"monokai","filters":["../filters/format_date_end.lua"],"output-file":"04-lesson.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["../files/bib/readings.bib"],"csl":"../files/bib/chicago-author-date.csl","_quarto-vars":{"author":"Andrew Heiss","instructor":{"name":"Dr. Andrew Heiss","name_no_title":"Andrew Heiss","email":"aheiss@gsu.edu","url":"https://www.andrewheiss.com","twitter":"andrewheiss","github":"andrewheiss","office":"55 Park Place SE, Room 464","contact_policy":"E-mail and Slack are the best ways to get in contact with me. I will try to respond to all course-related e-mails and Slack messages within 24 hours (*really*), but also remember that life can be busy and chaotic for everyone (including me!), so if I don't respond right away, don't worry!","appointment_url":"https://calendly.com/andrewheiss/"},"course":{"number":"PMAP 8551/4551","semester":"Fall 2023","days":"Any day","time":"Asynchronous","location":"Anywhere","dates":"August 12–December 11, 2023","github":"https://www.github.com/andrewheiss/datavizf23.classes.andrewheiss.com","url":"https://datavizf23.classes.andrewheiss.com","copyright_year":"2023","slack":"https://gsudatavizf2023.slack.com"},"university":{"name":"Georgia State University","url":"https://www.gsu.edu"},"school":{"name":"Andrew Young School of Policy Studies","url":"https://aysps.gsu.edu/"}},"theme":["litera","../html/custom.scss"],"date-heading":{"content":"Lesson for","class":"bg-lesson"},"date-format":"full","template-partials":["../html/title-block.html"],"title":"Amounts and proportions","date":"2023-09-11","date_end":"2023-09-15"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}