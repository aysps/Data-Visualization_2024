{"title":"Space","markdown":{"yaml":{"title":"Space","date":"2023-11-06","date_end":"2023-11-10"},"headingText":"Combining datasets vertically","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nknitr::opts_chunk$set(fig.align = \"center\", collapse = TRUE)\n```\n\n```{r learnr-setup, echo=FALSE, results=\"asis\"}\nsource(here::here(\"R\", \"learnr-things.R\"))\ninclude_iframe_resizer()\n```\n\nThere *is* a short lesson this week! You'll learn the basics of joining two different datasets together, both vertically and horizontally.\n\nThere are a few imaginary datasets I've created for you to play with:\n\n```{r create-fake-data, echo=FALSE}\nnational_data <- tribble(\n  ~state, ~year, ~unemployment, ~inflation, ~population,\n  \"GA\",   2018,  5,             2,          100,\n  \"GA\",   2019,  5.3,           1.8,        200,\n  \"GA\",   2020,  5.2,           2.5,        300,\n  \"NC\",   2018,  6.1,           1.8,        350,\n  \"NC\",   2019,  5.9,           1.6,        375,\n  \"NC\",   2020,  5.3,           1.8,        400,\n  \"CO\",   2018,  4.7,           2.7,        200,\n  \"CO\",   2019,  4.4,           2.6,        300,\n  \"CO\",   2020,  5.1,           2.5,        400\n)\n\npuerto_rico_data <- tribble(\n  ~state, ~unemployment, ~population, ~year,\n  \"PR\",   3.1,            150,        2018, \n  \"PR\",   3.2,            250,        2019, \n  \"PR\",   3.3,            350,        2020\n)\n\nnational_libraries <- tribble(\n  ~state, ~year, ~libraries, ~schools,\n  \"CO\",   2018,  230,        470,\n  \"CO\",   2019,  240,        440,\n  \"CO\",   2020,  270,        510,\n  \"NC\",   2018,  200,        610,\n  \"NC\",   2019,  210,        590,\n  \"NC\",   2020,  220,        530,\n)\n\nnational_data_2019 <- national_data %>% \n  filter(year == 2019) %>% select(-year)\n\nnational_libraries_2019 <- national_libraries %>% \n  filter(year == 2019) %>% select(-year)\n\nstate_regions <- tribble(\n  ~region, ~state,\n  \"Northeast\", c(\"CT\", \"ME\", \"MA\", \"NH\", \"RI\", \"VT\", \"NJ\", \"NY\", \"PA\"),\n  \"Midwest\", c(\"IL\", \"IN\", \"MI\", \"OH\", \"WI\", \"IA\", \"KS\", \"MN\", \"MO\", \"NE\", \"ND\", \"SD\"),\n  \"South\", c(\"DE\", \"FL\", \"GA\", \"MD\", \"NC\", \"SC\", \"VA\", \"DC\", \"WV\", \"AL\", \"KY\", \"MS\", \"TN\", \"AR\", \"LA\", \"OK\", \"TX\"),\n  \"West\", c(\"AZ\", \"CO\", \"ID\", \"MT\", \"NV\", \"NM\", \"UT\", \"WY\", \"AK\", \"CA\", \"HI\", \"OR\", \"WA\")\n) %>% unnest(state) %>% \n  arrange(state)\n\nx <- tibble(id = c(1, 2, 3),\n            some_variable = c(\"x1\", \"x2\", \"x3\"))\n\ny <- tibble(id = c(1, 2, 4),\n            some_other_variable = c(\"y1\", \"y2\", \"y4\"))\n```\n\n```{r}\nx\n```\n\n```{r}\ny\n```\n\n```{r}\nnational_data\n```\n\n```{r}\nnational_data_2019\n```\n\n```{r}\nnational_libraries\n```\n\n```{r}\nnational_libraries_2019\n```\n\n```{r}\npuerto_rico_data\n```\n\n```{r}\nstate_regions\n```\n\n\n\nRecall from the [Lord of the Rings data in exercise 3](/assignment/03-exercise.qmd) that you had to combine three different CSV files into dataset. You used `bind_rows()` to stack each of these on top of each other. \n\n```{r eval=FALSE}\nlotr <- bind_rows(fellowship, tt, rotk)\n```\n\nThat worked well because each of the individual data frames had the same columns in them, and R was able to line up the matching columns. If columns were missing, R would have placed `NA` in the appropriate locations.\n\n::: {.callout-important}\n### Your turn\n\nCombine `national_data` and `puerto_rico_data` into a single dataset named `us_data` using `bind_rows`. Pay attention to what happens with the inflation column. Also notice that the columns in the Puerto Rico data are in a different order.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-1/\",\n  id = \"learnr-12-lesson-joining1\"\n)\n```\n\n## Combining datasets horizontally\n\nBinding rows vertically is the easiest way to combine two datasets, but most often you won't be doing that. You'll only do this if you're combining datasets that come from the same source, like if a state offers separate CSV files of the same data for each county. \n\nIn most cases, though, you'll need to combine completely different datasets, bringing one or more columns from one into another. With vertical combining, R needs column names with the same names in order to figure out where the data lines up. With horizontal combining, R needs values inside one or more columns to be the same in order to figure out where the data lines up.\n\nThere is technically a function named `bind_cols()`, but you'll rarely want to use it. It doesn't attempt to match any rows—it just glues two datasets together:\n\n```{r show-bind-cols}\nbind_cols(national_data, \n          # Repeat PR 3 times so that it has the same number of rows as national_data\n          bind_rows(puerto_rico_data, puerto_rico_data, puerto_rico_data))\n```\n\nThat's… not great.\n\nInstead, we need to use a function that is more careful about bringing in data. Fortunately there are a few good options:\n\n- `inner_join()`\n- `left_join()`\n- `right_join()`\n\nThe **most** helpful way of understanding these different functions [is to go here and stare at the animations for a little while](https://github.com/gadenbuie/tidyexplain#mutating-joins) to see which pieces of which dataset go where. (There are lots of others, like `full_join()`, `semi_join()`, and `anti_join()`, and they have helpful animations, but I rarely use those.)\n\nFor each of these functions, **you need at least one common ID column in both datasets** in order for R to know where things line up.\n\nLet's practice how these all work and see what the differences between them are.\n\n## `inner_join()`\n\nFirst, <a href=\"https://github.com/gadenbuie/tidyexplain#inner-join\" target=\"_blank\">go to this page in a new tab</a> and stare at the mesmerizing animation.\n\nLet's look at two datasets, `x` and `y`:\n\n```{r}\nx\n```\n\n```{r}\ny\n```\n\nBoth datasets have an `id` column that is the same across each (though the values aren't necessarily the same). Because there's a shared column, we can join these two based on that column.\n\nIf we use `inner_join()`, the resulting dataset will only keep the rows from the first where there are matching values from the second:\n\n```{r}\ninner_join(x, y, by = \"id\")\n```\n\nNotice how it got rid of the row with `id = 3` from the first and the row with `id = 4` from the second. \n\nYou can also write this with pipes, which is really common when working with {dplyr}:\n\n```{r}\nx %>% \n  inner_join(y, by = \"id\")\n```\n\nLet's say we have two datasets: `national_data_2019` and `national_libraries_2019`:\n\n```{r}\nnational_data_2019\n```\n\n```{r}\nnational_libraries_2019\n```\n\nWe want to bring the libraries and schools columns into the general national data. Notice how both datasets have a state column.\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `combined_data` that uses `inner_join()` to merge `national_data_2019` and `national_libraries_2019`.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-2/\",\n  id = \"learnr-12-lesson-joining2\"\n)\n```\n\n## `left_join()`\n\nAgain, <a href=\"https://github.com/gadenbuie/tidyexplain#left-join\" target=\"_blank\">go to this page in a new tab</a> and stare at the animation.\n\nLeft joining is less destructive than inner joining. With left joining, any rows in the first dataset that don't have matches in the second *don't* get thrown away and instead are filled with `NA`:\n\n```{r}\nleft_join(x, y, by = \"id\")\n```\n\nNotice how the row with `id = 4` from the second dataset is gone, but the row with `id = 3` from the first is still there, with `NA` for `some_other_variable`.\n\nI find this much more useful when combining data. I often have a larger dataset with all the main variables I care about, perhaps with every combination of country and year over 20 years and 180 countries. If I find another dataset I want to join, and it has missing data for some of the years or countries, I don't want the combined data to throw away all the rows from the main big dataset that don't match! I still want those! \n\n*([Look at this for a real life example](https://stats.andrewheiss.com/canary-ngos/01_get-merge-data.html#final_clean_combined_data): I create a dataset I name `panel_skeleton` that is just all the combinations of countries and years (Afghanistan 1990, Afghanistan 1991, etc.), and then I bring in all sorts of other datasets that match the same countries and years. When there aren't matches, nothing in the skeleton gets thrown away—R just adds missing values instead.)*\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `combined_data` that uses `left_join()` to merge `national_data_2019` and `national_libraries_2019`.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-5/\",\n  id = \"learnr-12-lesson-joining5\"\n)\n```\n\nLeft joining is also often surprisingly helpful for recoding lots of variables. Right now in our fake national data, we have a column for state, but it would be nice if we could have a column for region so we could facet or fill or color by region in a plot. Hunting around on the internet, you find this dataset that has a column for state and a column for abbreviations:\n\n```{r}\nstate_regions\n```\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `national_data_with_region` that uses `left_join()` to combine `national_data_2019` with `state_regions`.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-3/\",\n  id = \"learnr-12-lesson-joining3\"\n)\n```\n\nBecause `left_join()` only keeps rows from the second dataset that match the first, we don't actually bring in all 50 rows from the `state_regions` data—only the rows that match the first dataset (`national_data_2019`) come over. We could have done with if some massive recoding (`mutate(region = ifelse(state == \"GA\" | state == \"NC\", \"South\", ifelse(state == \"CO\"), \"West\", NA))`), but that's awful. Left joining is far easier here.\n\nYou can also join by multiple columns. So far we've been working with just `national_data_2019`, but if you look at `national_data`, you'll see there are rows for different years across these states:\n\n```{r}\nnational_data\n```\n\nPreviously, we've been specifying the ID column with `by = \"state\"`, but now we have two ID columns: `state` and `year`. We can specify both with `by = c(\"state\", \"year\")`.\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `national_data_combined` that uses `left_join()` to combine `national_data` with `national_libraries` by state and year.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-4/\",\n  id = \"learnr-12-lesson-joining4\"\n)\n```\n\nIf one dataset has things like state and year, but another only has state, `left_join()` will still work, but it will only join where the state is the same. For instance, here's what happens when we join the region data to the yearly national data:\n\n```{r}\nnational_data_with_region <- national_data %>% \n  left_join(state_regions, by = \"state\")\nnational_data_with_region\n```\n\nThe \"South\" region gets added to every row where the state is \"GA\" and \"NC\", even though those rows only appear once in `state_regions`. `left_join()` will still match all the values even if states are repeated. Magic!\n\n## Common column names\n\nSo far, the column names in both datasets have been the same, which has greatly simplified life. In fact, if the columns have the same name, we can technically leave out the `by` argument and R will guess:\n\n```{r}\nnational_data %>% \n  left_join(national_libraries)\n```\n\nIt's good practice to be specific about the columns you want and actually use `by`, but I will often run `left_join()` without it and then copy the message that it generates (\"`by = c(\"state\", \"year\")`\") and paste it into my code. \n\nBut what if the column names don't match? Let's rename the state column in our state/region table for fun:\n\n```{r}\nstate_regions_different <- state_regions %>% \n  rename(ST = state)\nstate_regions_different\n```\n\nNow watch what happens when we try to join the datasets:\n\n```{r error=TRUE}\nnational_data %>% \n  left_join(state_regions_different)\n```\n\nThere are no common variables, so we get an error. The `state` and `ST` columns really are common variables, but R doesn't know that.\n\nWe have two options:\n\n1. Rename one of the columns so it matches (either change `state` to `ST` or change `ST` to `state`)\n2. Tell `left_join()` which columns are the same\n\nWe can do option two by modifying the `by` argument like so:\n\n```{r}\nnational_data %>% \n  left_join(state_regions_different, by = c(\"state\" = \"ST\"))\n```\n\n\n## `right_join()`\n\nOnce again, <a href=\"https://github.com/gadenbuie/tidyexplain#right-join\" target=\"_blank\">go to this page in a new tab</a> and watch the animation.\n\n`right_join()` works exactly like `left_join()`, but in reverse. The *second* dataset is the base data. Any rows in the second dataset that don't match in the first will be kept, and any rows from the first that don't match will get thrown away.\n\nWatch what happens if we right join `national_data` and `state_regions`:\n\n```{r}\nnational_data %>% \n  right_join(state_regions, by = \"state\")\n```\n\nYikes. R kept all the rows in `state_regions`, brought in the columns from `national_data` and filled most of the new columns with `NA`, and then repeated Colorado (and NC and GA) three times for each of the years from `national_data`. That's a mess.\n\nIf we reverse the order, we'll get the correct merged data:\n\n```{r}\nstate_regions %>% \n  right_join(national_data, by = \"state\")\n```\n\nI rarely use `right_join()` because I find it more intuitive to just use `left_join()` since in my head, I'm taking a dataset and stacking columns onto the end of it. If you want to right join instead, neat—just remember to order things correctly.\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nknitr::opts_chunk$set(fig.align = \"center\", collapse = TRUE)\n```\n\n```{r learnr-setup, echo=FALSE, results=\"asis\"}\nsource(here::here(\"R\", \"learnr-things.R\"))\ninclude_iframe_resizer()\n```\n\nThere *is* a short lesson this week! You'll learn the basics of joining two different datasets together, both vertically and horizontally.\n\nThere are a few imaginary datasets I've created for you to play with:\n\n```{r create-fake-data, echo=FALSE}\nnational_data <- tribble(\n  ~state, ~year, ~unemployment, ~inflation, ~population,\n  \"GA\",   2018,  5,             2,          100,\n  \"GA\",   2019,  5.3,           1.8,        200,\n  \"GA\",   2020,  5.2,           2.5,        300,\n  \"NC\",   2018,  6.1,           1.8,        350,\n  \"NC\",   2019,  5.9,           1.6,        375,\n  \"NC\",   2020,  5.3,           1.8,        400,\n  \"CO\",   2018,  4.7,           2.7,        200,\n  \"CO\",   2019,  4.4,           2.6,        300,\n  \"CO\",   2020,  5.1,           2.5,        400\n)\n\npuerto_rico_data <- tribble(\n  ~state, ~unemployment, ~population, ~year,\n  \"PR\",   3.1,            150,        2018, \n  \"PR\",   3.2,            250,        2019, \n  \"PR\",   3.3,            350,        2020\n)\n\nnational_libraries <- tribble(\n  ~state, ~year, ~libraries, ~schools,\n  \"CO\",   2018,  230,        470,\n  \"CO\",   2019,  240,        440,\n  \"CO\",   2020,  270,        510,\n  \"NC\",   2018,  200,        610,\n  \"NC\",   2019,  210,        590,\n  \"NC\",   2020,  220,        530,\n)\n\nnational_data_2019 <- national_data %>% \n  filter(year == 2019) %>% select(-year)\n\nnational_libraries_2019 <- national_libraries %>% \n  filter(year == 2019) %>% select(-year)\n\nstate_regions <- tribble(\n  ~region, ~state,\n  \"Northeast\", c(\"CT\", \"ME\", \"MA\", \"NH\", \"RI\", \"VT\", \"NJ\", \"NY\", \"PA\"),\n  \"Midwest\", c(\"IL\", \"IN\", \"MI\", \"OH\", \"WI\", \"IA\", \"KS\", \"MN\", \"MO\", \"NE\", \"ND\", \"SD\"),\n  \"South\", c(\"DE\", \"FL\", \"GA\", \"MD\", \"NC\", \"SC\", \"VA\", \"DC\", \"WV\", \"AL\", \"KY\", \"MS\", \"TN\", \"AR\", \"LA\", \"OK\", \"TX\"),\n  \"West\", c(\"AZ\", \"CO\", \"ID\", \"MT\", \"NV\", \"NM\", \"UT\", \"WY\", \"AK\", \"CA\", \"HI\", \"OR\", \"WA\")\n) %>% unnest(state) %>% \n  arrange(state)\n\nx <- tibble(id = c(1, 2, 3),\n            some_variable = c(\"x1\", \"x2\", \"x3\"))\n\ny <- tibble(id = c(1, 2, 4),\n            some_other_variable = c(\"y1\", \"y2\", \"y4\"))\n```\n\n```{r}\nx\n```\n\n```{r}\ny\n```\n\n```{r}\nnational_data\n```\n\n```{r}\nnational_data_2019\n```\n\n```{r}\nnational_libraries\n```\n\n```{r}\nnational_libraries_2019\n```\n\n```{r}\npuerto_rico_data\n```\n\n```{r}\nstate_regions\n```\n\n\n## Combining datasets vertically\n\nRecall from the [Lord of the Rings data in exercise 3](/assignment/03-exercise.qmd) that you had to combine three different CSV files into dataset. You used `bind_rows()` to stack each of these on top of each other. \n\n```{r eval=FALSE}\nlotr <- bind_rows(fellowship, tt, rotk)\n```\n\nThat worked well because each of the individual data frames had the same columns in them, and R was able to line up the matching columns. If columns were missing, R would have placed `NA` in the appropriate locations.\n\n::: {.callout-important}\n### Your turn\n\nCombine `national_data` and `puerto_rico_data` into a single dataset named `us_data` using `bind_rows`. Pay attention to what happens with the inflation column. Also notice that the columns in the Puerto Rico data are in a different order.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-1/\",\n  id = \"learnr-12-lesson-joining1\"\n)\n```\n\n## Combining datasets horizontally\n\nBinding rows vertically is the easiest way to combine two datasets, but most often you won't be doing that. You'll only do this if you're combining datasets that come from the same source, like if a state offers separate CSV files of the same data for each county. \n\nIn most cases, though, you'll need to combine completely different datasets, bringing one or more columns from one into another. With vertical combining, R needs column names with the same names in order to figure out where the data lines up. With horizontal combining, R needs values inside one or more columns to be the same in order to figure out where the data lines up.\n\nThere is technically a function named `bind_cols()`, but you'll rarely want to use it. It doesn't attempt to match any rows—it just glues two datasets together:\n\n```{r show-bind-cols}\nbind_cols(national_data, \n          # Repeat PR 3 times so that it has the same number of rows as national_data\n          bind_rows(puerto_rico_data, puerto_rico_data, puerto_rico_data))\n```\n\nThat's… not great.\n\nInstead, we need to use a function that is more careful about bringing in data. Fortunately there are a few good options:\n\n- `inner_join()`\n- `left_join()`\n- `right_join()`\n\nThe **most** helpful way of understanding these different functions [is to go here and stare at the animations for a little while](https://github.com/gadenbuie/tidyexplain#mutating-joins) to see which pieces of which dataset go where. (There are lots of others, like `full_join()`, `semi_join()`, and `anti_join()`, and they have helpful animations, but I rarely use those.)\n\nFor each of these functions, **you need at least one common ID column in both datasets** in order for R to know where things line up.\n\nLet's practice how these all work and see what the differences between them are.\n\n## `inner_join()`\n\nFirst, <a href=\"https://github.com/gadenbuie/tidyexplain#inner-join\" target=\"_blank\">go to this page in a new tab</a> and stare at the mesmerizing animation.\n\nLet's look at two datasets, `x` and `y`:\n\n```{r}\nx\n```\n\n```{r}\ny\n```\n\nBoth datasets have an `id` column that is the same across each (though the values aren't necessarily the same). Because there's a shared column, we can join these two based on that column.\n\nIf we use `inner_join()`, the resulting dataset will only keep the rows from the first where there are matching values from the second:\n\n```{r}\ninner_join(x, y, by = \"id\")\n```\n\nNotice how it got rid of the row with `id = 3` from the first and the row with `id = 4` from the second. \n\nYou can also write this with pipes, which is really common when working with {dplyr}:\n\n```{r}\nx %>% \n  inner_join(y, by = \"id\")\n```\n\nLet's say we have two datasets: `national_data_2019` and `national_libraries_2019`:\n\n```{r}\nnational_data_2019\n```\n\n```{r}\nnational_libraries_2019\n```\n\nWe want to bring the libraries and schools columns into the general national data. Notice how both datasets have a state column.\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `combined_data` that uses `inner_join()` to merge `national_data_2019` and `national_libraries_2019`.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-2/\",\n  id = \"learnr-12-lesson-joining2\"\n)\n```\n\n## `left_join()`\n\nAgain, <a href=\"https://github.com/gadenbuie/tidyexplain#left-join\" target=\"_blank\">go to this page in a new tab</a> and stare at the animation.\n\nLeft joining is less destructive than inner joining. With left joining, any rows in the first dataset that don't have matches in the second *don't* get thrown away and instead are filled with `NA`:\n\n```{r}\nleft_join(x, y, by = \"id\")\n```\n\nNotice how the row with `id = 4` from the second dataset is gone, but the row with `id = 3` from the first is still there, with `NA` for `some_other_variable`.\n\nI find this much more useful when combining data. I often have a larger dataset with all the main variables I care about, perhaps with every combination of country and year over 20 years and 180 countries. If I find another dataset I want to join, and it has missing data for some of the years or countries, I don't want the combined data to throw away all the rows from the main big dataset that don't match! I still want those! \n\n*([Look at this for a real life example](https://stats.andrewheiss.com/canary-ngos/01_get-merge-data.html#final_clean_combined_data): I create a dataset I name `panel_skeleton` that is just all the combinations of countries and years (Afghanistan 1990, Afghanistan 1991, etc.), and then I bring in all sorts of other datasets that match the same countries and years. When there aren't matches, nothing in the skeleton gets thrown away—R just adds missing values instead.)*\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `combined_data` that uses `left_join()` to merge `national_data_2019` and `national_libraries_2019`.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-5/\",\n  id = \"learnr-12-lesson-joining5\"\n)\n```\n\nLeft joining is also often surprisingly helpful for recoding lots of variables. Right now in our fake national data, we have a column for state, but it would be nice if we could have a column for region so we could facet or fill or color by region in a plot. Hunting around on the internet, you find this dataset that has a column for state and a column for abbreviations:\n\n```{r}\nstate_regions\n```\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `national_data_with_region` that uses `left_join()` to combine `national_data_2019` with `state_regions`.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-3/\",\n  id = \"learnr-12-lesson-joining3\"\n)\n```\n\nBecause `left_join()` only keeps rows from the second dataset that match the first, we don't actually bring in all 50 rows from the `state_regions` data—only the rows that match the first dataset (`national_data_2019`) come over. We could have done with if some massive recoding (`mutate(region = ifelse(state == \"GA\" | state == \"NC\", \"South\", ifelse(state == \"CO\"), \"West\", NA))`), but that's awful. Left joining is far easier here.\n\nYou can also join by multiple columns. So far we've been working with just `national_data_2019`, but if you look at `national_data`, you'll see there are rows for different years across these states:\n\n```{r}\nnational_data\n```\n\nPreviously, we've been specifying the ID column with `by = \"state\"`, but now we have two ID columns: `state` and `year`. We can specify both with `by = c(\"state\", \"year\")`.\n\n::: {.callout-important}\n### Your turn\n\nCreate a new dataset named `national_data_combined` that uses `left_join()` to combine `national_data` with `national_libraries` by state and year.\n\n:::\n\n```{r echo=FALSE, results=\"asis\"}\nembedded_learnr(\n  url = \"https://andrewheiss.shinyapps.io/datavizm20_12-joining-4/\",\n  id = \"learnr-12-lesson-joining4\"\n)\n```\n\nIf one dataset has things like state and year, but another only has state, `left_join()` will still work, but it will only join where the state is the same. For instance, here's what happens when we join the region data to the yearly national data:\n\n```{r}\nnational_data_with_region <- national_data %>% \n  left_join(state_regions, by = \"state\")\nnational_data_with_region\n```\n\nThe \"South\" region gets added to every row where the state is \"GA\" and \"NC\", even though those rows only appear once in `state_regions`. `left_join()` will still match all the values even if states are repeated. Magic!\n\n## Common column names\n\nSo far, the column names in both datasets have been the same, which has greatly simplified life. In fact, if the columns have the same name, we can technically leave out the `by` argument and R will guess:\n\n```{r}\nnational_data %>% \n  left_join(national_libraries)\n```\n\nIt's good practice to be specific about the columns you want and actually use `by`, but I will often run `left_join()` without it and then copy the message that it generates (\"`by = c(\"state\", \"year\")`\") and paste it into my code. \n\nBut what if the column names don't match? Let's rename the state column in our state/region table for fun:\n\n```{r}\nstate_regions_different <- state_regions %>% \n  rename(ST = state)\nstate_regions_different\n```\n\nNow watch what happens when we try to join the datasets:\n\n```{r error=TRUE}\nnational_data %>% \n  left_join(state_regions_different)\n```\n\nThere are no common variables, so we get an error. The `state` and `ST` columns really are common variables, but R doesn't know that.\n\nWe have two options:\n\n1. Rename one of the columns so it matches (either change `state` to `ST` or change `ST` to `state`)\n2. Tell `left_join()` which columns are the same\n\nWe can do option two by modifying the `by` argument like so:\n\n```{r}\nnational_data %>% \n  left_join(state_regions_different, by = c(\"state\" = \"ST\"))\n```\n\n\n## `right_join()`\n\nOnce again, <a href=\"https://github.com/gadenbuie/tidyexplain#right-join\" target=\"_blank\">go to this page in a new tab</a> and watch the animation.\n\n`right_join()` works exactly like `left_join()`, but in reverse. The *second* dataset is the base data. Any rows in the second dataset that don't match in the first will be kept, and any rows from the first that don't match will get thrown away.\n\nWatch what happens if we right join `national_data` and `state_regions`:\n\n```{r}\nnational_data %>% \n  right_join(state_regions, by = \"state\")\n```\n\nYikes. R kept all the rows in `state_regions`, brought in the columns from `national_data` and filled most of the new columns with `NA`, and then repeated Colorado (and NC and GA) three times for each of the years from `national_data`. That's a mess.\n\nIf we reverse the order, we'll get the correct merged data:\n\n```{r}\nstate_regions %>% \n  right_join(national_data, by = \"state\")\n```\n\nI rarely use `right_join()` because I find it more intuitive to just use `left_join()` since in my head, I'm taking a dataset and stacking columns onto the end of it. If you want to right join instead, neat—just remember to order things correctly.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"monokai","filters":["../filters/format_date_end.lua"],"output-file":"12-lesson.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["../files/bib/readings.bib"],"csl":"../files/bib/chicago-author-date.csl","_quarto-vars":{"author":"Andrew Heiss","instructor":{"name":"Dr. Andrew Heiss","name_no_title":"Andrew Heiss","email":"aheiss@gsu.edu","url":"https://www.andrewheiss.com","twitter":"andrewheiss","github":"andrewheiss","office":"55 Park Place SE, Room 464","contact_policy":"E-mail and Slack are the best ways to get in contact with me. I will try to respond to all course-related e-mails and Slack messages within 24 hours (*really*), but also remember that life can be busy and chaotic for everyone (including me!), so if I don't respond right away, don't worry!","appointment_url":"https://calendly.com/andrewheiss/"},"course":{"number":"PMAP 8551/4551","semester":"Fall 2023","days":"Any day","time":"Asynchronous","location":"Anywhere","dates":"August 12–December 11, 2023","github":"https://www.github.com/andrewheiss/datavizf23.classes.andrewheiss.com","url":"https://datavizf23.classes.andrewheiss.com","copyright_year":"2023","slack":"https://gsudatavizf2023.slack.com"},"university":{"name":"Georgia State University","url":"https://www.gsu.edu"},"school":{"name":"Andrew Young School of Policy Studies","url":"https://aysps.gsu.edu/"}},"theme":["litera","../html/custom.scss"],"date-heading":{"content":"Lesson for","class":"bg-lesson"},"date-format":"full","template-partials":["../html/title-block.html"],"title":"Space","date":"2023-11-06","date_end":"2023-11-10"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}