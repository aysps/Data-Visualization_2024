{"title":"Space","markdown":{"yaml":{"title":"Space","date":"2023-11-06","date_end":"2023-11-10"},"headingText":"Shapefiles","containsRefs":false,"markdown":"\n\n```{r load-targets, include=FALSE}\nwithr::with_dir(here::here(), {\n  geocoded_path <- targets::tar_read(data_geocoded)\n  wdi_path <- targets::tar_read(data_wdi_lifeexp)\n})\n```\n\n\nShapefiles are special types of data that include information about geography, such as points (latitude, longitude), paths (a bunch of connected latitudes and longitudes) and areas (a bunch of connected latitudes and longitudes that form a complete shape). Nowadays, most government agencies provide shapefiles for their jurisdictions. For global mapping data, you can use the Natural Earth project:\n\n- [Natural Earth](https://www.naturalearthdata.com/)\n- [US Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html)\n- [Georgia GIS Clearinghouse](https://data.georgiaspatial.org/) (requires a free account; the interface is *incredibly* clunky)\n- [Atlanta Regional Council](https://opendata.atlantaregional.com/)\n- [Fulton County GIS Portal](https://gisdata.fultoncountyga.gov/)\n- [City of Atlanta, Department of City Planning](https://dcp-coaplangis.opendata.arcgis.com/)\n\n\n## Projections and coordinate reference systems\n\nAs you read in this week's readings, projections matter a lot for maps. You can convert your geographic data between different coordinate systems (or projections) fairly easily with {sf}. You can use `coord_sf(crs = st_crs(\"XXXX\"))` to convert coordinate reference systems (CRS) as you plot, or use `st_transform()` to convert data frames to a different CRS.\n\n::: {.callout-note}\n### Not 100% correct\n\nTECHNICALLY coordinate systems and projection systems [are different things](https://gis.stackexchange.com/a/149751/56265), but I'm not a geographer and I don't care that much about the nuance.\n:::\n\nThere are standard indexes of more than 4,000 of these projections (!!!) at [epsg.io](https://epsg.io/). \n\n**Super important**: When using these projections, you need to specify both the projection catalog (ESRI or EPSG; [see here for the difference](https://gis.stackexchange.com/a/169211/56265)) and the projection number, separated by a colon (e.g. \"`ESRI:54030`\"). Fortunately [epsg.io](http://epsg.io/) makes this super easy: go to the epsg.io page for the projection you want to use and the page title will have the correct name. \n\nHere are some common ones:\n\n- [ESRI:54002](http://epsg.io/54002): Equidistant cylindrical projection for the world[^gall-peters]\n- [EPSG:3395](http://epsg.io/3395): Mercator projection for the world\n- [ESRI:54008](http://epsg.io/54008): Sinusoidal projection for the world\n- [ESRI:54009](http://epsg.io/54009): Mollweide projection for the world\n- [ESRI:54030](http://epsg.io/54030): Robinson projection for the world (This is my favorite world projection.)\n- [EPSG:4326](http://epsg.io/4326): WGS 84: DOD GPS coordinates (standard −180 to 180 system)\n- [EPSG:4269](http://epsg.io/4269): NAD 83: Relatively common projection for North America\n- [ESRI:102003](https://epsg.io/102003): Albers projection specifically for the contiguous United States\n\n[^gall-peters]: This is essentially the [Gall-Peters projection](https://en.wikipedia.org/wiki/Gall%E2%80%93Peters_projection) from [the West Wing clip](https://www.youtube.com/watch?v=vVX-PrBRtTY).\n\nAlternatively, instead of using these index numbers, you can use any of the names listed [here](https://proj.org/operations/projections/index.html), such as:\n\n- `\"+proj=merc\"`: Mercator\n- `\"+proj=robin\"`: Robinson\n- `\"+proj=moll\"`: Mollweide \n- `\"+proj=aeqd\"`: Azimuthal Equidistant\n- `\"+proj=cass\"`: Cassini-Soldner\n\n\n## Shapefiles to download\n\nI use a lot of different shapefiles in this example. To save you from having to go find and download each individual one, you can download this zip file:\n\n- [{{< fa file-archive >}} `shapefiles.zip`](/files/data/external_data/shapefiles.zip)\n\nUnzip this and put all the contained folders in a folder named `data` if you want to follow along. **You don't need to follow along!**\n\nYour project should be structured like this:\n\n```default\nyour-project-name\\\n  some-name.Rmd\n  your-project-name.Rproj\n  data\\\n    cb_2022_us_county_5m\\\n      ...\n      cb_2022_us_county_5m.shp\n      ...\n    cb_2022_us_state_20m\\\n    ne_10m_admin_1_states_provinces\\\n    ne_10m_lakes\\\n    ne_10m_rivers_lake_centerlines\\\n    ne_10m_rivers_north_america\\\n    ne_110m_admin_0_countries\\\n    schools_2009\\\n```\n\nThese shapefiles all came from these sources:\n\n- {{< fa map >}} **World map**: [110m \"Admin 0 - Countries\" from Natural Earth](https://www.naturalearthdata.com/downloads/110m-cultural-vectors/)\n- {{< fa map >}} **US states**: [20m 2022 state boundaries from the US Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html)\n- {{< fa map >}} **US counties**: [5m 2022 county boundaries from the US Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html)\n- {{< fa map >}} **US states high resolution**: [10m \"Admin 1 – States, Provinces\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/)\n- {{< fa map >}} **Global rivers**: [10m \"Rivers + lake centerlines\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/)\n- {{< fa map >}} **North American rivers**: [10m \"Rivers + lake centerlines, North America supplement\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-physical-vectors/)\n- {{< fa map >}} **Global lakes**: [10m \"Lakes + Reservoirs\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-physical-vectors/)\n- {{< fa map >}} **Georgia K–12 schools, 2009**: [\"Georgia K-12 Schools\" from the Georgia Department of Education](https://data.georgiaspatial.org/index.asp?body=preview&dataId=41516) *(you must be logged in to access this)*\n\n\n## Live coding example\n\n<div class=\"ratio ratio-16x9\">\n<iframe src=\"https://www.youtube.com/embed/Opzwtegvuv4\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\"></iframe>\n</div>\n\n\n::: {.callout-important}\n### Slight differences from the video\n\nThis is a slightly cleaned up version of the code from the video.\n:::\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(fig.width = 6, fig.height = 3.6, fig.align = \"center\", collapse = TRUE)\nset.seed(1234)\noptions(\"digits\" = 2, \"width\" = 150)\n```\n\n## Load and look at data\n\nFirst we'll load the libraries we're going to use:\n\n```{r load-libraries, message=FALSE, warning=FALSE}\nlibrary(tidyverse)  # For ggplot, dplyr, and friends\nlibrary(sf)         # For GIS magic\n```\n\nNext we'll load all the different shapefiles we downloaded using `read_sf()`: \n\n```{r load-shapefiles-fake, eval=FALSE}\n# Download \"Admin 0 – Countries\" from\n# https://www.naturalearthdata.com/downloads/110m-cultural-vectors/\nworld_map <- read_sf(\"data/ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp\")\n\n# Download cb_2022_us_state_20m.zip under \"States\" from\n# https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html\nus_states <- read_sf(\"data/cb_2022_us_state_20m/cb_2022_us_state_20m.shp\")\n\n# Download cb_2022_us_county_5m.zip under \"County\" from\n# https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html\nus_counties <- read_sf(\"data/cb_2022_us_county_5m/cb_2022_us_county_5m.shp\")\n\n# Download \"Admin 1 – States, Provinces\" from\n# https://www.naturalearthdata.com/downloads/10m-cultural-vectors/\nus_states_hires <- read_sf(\"data/ne_10m_admin_1_states_provinces/ne_10m_admin_1_states_provinces.shp\")\n\n# Download \"Rivers + lake centerlines\" from\n# https://www.naturalearthdata.com/downloads/10m-physical-vectors/\nrivers_global <- read_sf(\"data/ne_10m_rivers_lake_centerlines/ne_10m_rivers_lake_centerlines.shp\")\n\n# Download \"Rivers + lake centerlines, North America supplement\" from\n# https://www.naturalearthdata.com/downloads/10m-physical-vectors/\nrivers_na <- read_sf(\"data/ne_10m_rivers_north_america/ne_10m_rivers_north_america.shp\")\n\n# Download \"Lakes + Reservoirs\" from\n# https://www.naturalearthdata.com/downloads/10m-physical-vectors/\nlakes <- read_sf(\"data/ne_10m_lakes/ne_10m_lakes.shp\")\n\n# Download from https://data.georgiaspatial.org/index.asp?body=preview&dataId=41516\n# after creating an account and logging in\nga_schools <- read_sf(\"data/schools_2009/DOE Schools 2009.shp\")\n```\n\n```{r load-shapefiles-real, include=FALSE}\nworld_map <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                \"ne_110m_admin_0_countries\", \n                                \"ne_110m_admin_0_countries.shp\"))\n\nus_states <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                \"cb_2022_us_state_20m\",\n                                \"cb_2022_us_state_20m.shp\"))\n\nus_states_hires <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                      \"ne_10m_admin_1_states_provinces\",\n                                      \"ne_10m_admin_1_states_provinces.shp\"))\n\nus_counties <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                  \"cb_2022_us_county_5m\",\n                                  \"cb_2022_us_county_5m.shp\"))\n\nrivers_global <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                    \"ne_10m_rivers_lake_centerlines\",\n                                    \"ne_10m_rivers_lake_centerlines.shp\"))\n\nrivers_na <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                \"ne_10m_rivers_north_america\",\n                                \"ne_10m_rivers_north_america.shp\"))\n\nlakes <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                            \"ne_10m_lakes\", \"ne_10m_lakes.shp\"))\n\nga_schools <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                 \"schools_2009\", \"DOE Schools 2009.shp\"))\n\ngeocoded_addresses <- read_csv(here::here(geocoded_path))\n```\n\n## Basic plotting\n\nIf you look at the `world_map` dataset in RStudio, you'll see it's just a standard data frame with `r nrow(world_map)` rows and `r ncol(world_map)` columns. The last column is the magical `geometry` column with the latitude/longitude details for the borders for every country. RStudio only shows you 50 columns at a time in the RStudio viewer, so you'll need to move to the next page of columns with the » button in the top left corner.\n\nBecause this is just a data frame, we can do all our normal dplyr things to it. Let's get rid of Antarctica, since it takes up a big proportion of the southern hemisphere:\n\n```{r world-sans-ata}\nworld_sans_antarctica <- world_map %>% \n  filter(ISO_A3 != \"ATA\")\n```\n\nReady to plot a map? Here's all you need to do:\n\n```{r map-super-basic}\nggplot() + \n  geom_sf(data = world_sans_antarctica)\n```\n\nIf you couldn't tell from the lecture, I'm completely blown away by how amazingly easy this every time I plot a map :)\n\nBecause this a regular ggplot geom, all our regular aesthetics and themes and everything work:\n\n```{r map-super-basic-filled}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  theme_void()\n```\n\nThe Natural Earth dataset happens to come with some columns with a coloring scheme with 7–13 colors (`MAPCOLOR7`, `MAPCOLOR9`, etc.) so that no countries with a shared border share a color. We can fill by that column:\n\n```{r map-super-basic-filled-7}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          aes(fill = as.factor(MAPCOLOR7)),\n          color = \"#401D16\", linewidth = 0.25) +\n  scale_fill_viridis_d(option = \"plasma\") +\n  guides(fill = \"none\") +\n  theme_void()\n```\n\n## World map with different projections\n\nChanging projections is trivial: add a `coord_sf()` layer where you specify the CRS you want to use.\n\nHere's Robinson (yay):\n\n```{r map-basic-robinson}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  # Or use the name instead of the number\n  # coord_sf(crs = \"+proj=robin\")\n  theme_void()\n```\n\nHere's sinusoidal:\n\n```{r map-basic-sinusoidal}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54008\")) +  # Sinusoidal\n  theme_void()\n```\n\nAnd here's Mercator (ewww):\n\n```{r map-basic-mercator}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"EPSG:3395\")) +  # Mercator\n  # Or use the name instead of the number\n  # coord_sf(crs = \"+proj=merc\")\n  theme_void()\n```\n\n## US map with different projections\n\nThis same process works for any shapefile. The map of the US can also be projected differently—two common projections are NAD83 and Albers. We'll take the `us_states` dataset, remove Alaska, Hawaii, and Puerto Rico (they're so far from the rest of the lower 48 states that they make an unusable map—see the next section for a way to include them), and plot it.\n\n```{r us-nad83}\nlower_48 <- us_states %>% \n  filter(!(NAME %in% c(\"Alaska\", \"Hawaii\", \"Puerto Rico\")))\n\nggplot() + \n  geom_sf(data = lower_48, fill = \"#192DA1\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"EPSG:4269\")) +  # NAD83\n  theme_void()\n```\n\n```{r us-albers}\nggplot() + \n  geom_sf(data = lower_48, fill = \"#192DA1\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n## US map with non-continguous parts\n\nPlotting places like Alaska, Hawaii, and Puerto Rico gets a little tricky since they're far away from the contiguous 48 states. There's an easy way to handle it though!\n\nFirst, there's a package named [{tigris}](https://github.com/walkerke/tigris) that provides a neat interface for working with spatial data from the [US Census's TIGER shapefiles](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.html). In addition to providing a ton of functions for getting shapefiles for states, counties, voting districts, Tribal areas, military bases, and dozens of other things, {tigris} has a `shift_geometry()` function that will change the coordinates for Alaska, Hawaii, and Puerto Rico so that they end up in Mexico and the Gulf of Mexico.\n\n\n```{r tigris-shifting, warning=FALSE, message=FALSE}\nlibrary(tigris)\n\n# This is the Census shapefile we loaded earlier. Note how we're not filtering\n# out AK, HI, and PR now\nus_states_shifted <- us_states %>% \n  shift_geometry()  # Move AK, HI, and PR around\n\nggplot() +\n  geom_sf(data = us_states_shifted) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\nThe `shift_geometry()` function should work on any shapefile. What if you have a shapefile with the coordinates of all public libraries in Alaska? Those will use the actual coordinates, not the shifted-to-Mexico coordinates. Feed that data to `shift_geometry()` and it should translate any coordinates you have in Alaska, Hawaii, and Puerto Rico to the Mexico area so they'll plot correctly.\n\n`shift_geometry()` has an optional `position` argument that lets you control where the non-contiguous states go. By default they'll go below the continental US (`position = \"below\"`), but you can also use `position = \"outside\"` to place them more in relation to where they are in real life:\n\n```{r tigris-shifting-alt}\nus_states_shifted <- us_states %>% \n  shift_geometry(position = \"outside\")\n\nggplot() +\n  geom_sf(data = us_states_shifted) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n\n## Individual states\n\nAgain, because these shapefiles are really just fancy data frames, we can filter them with normal dplyr functions. Let's plot just Georgia:\n\n```{r georgia-only}\nonly_georgia <- lower_48 %>% \n  filter(NAME == \"Georgia\")\n\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  theme_void()\n```\n\nWe can also use a different projection. If we look at [epsg.io](http://epsg.io/), there's [a version of NAD83 that's focused specifically on Georgia](http://epsg.io/2239-1713). \n\n```{r georgia-only-projection}\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  theme_void() +\n  coord_sf(crs = st_crs(\"EPSG:2239\"))  # NAD83 focused on Georgia\n```\n\nThere's one small final issue though: we're missing all the Atlantic islands in the southeast like Cumberland Island and Amelia Island. That's because we're using the Census's low resolution (20m) data. That's fine for the map of the whole country, but if we're looking at a single state, we probably want better detail in the borders. We can use the Census's high resolution (500k) data, but even then it doesn't include the islands for whatever reason, but [Natural Earth has high resolution US state data](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-1-states-provinces/) that *does* have the islands, so we can use that:\n\n```{r georgia-only-hires}\nonly_georgia_high <- us_states_hires %>% \n  filter(iso_3166_2 == \"US-GA\")\n\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  theme_void() +\n  coord_sf(crs = st_crs(\"EPSG:2239\"))  # NAD83 focused on Georgia\n```\n\nPerfect.\n\n\n## Plotting multiple shapefile layers\n\nThe state shapefiles from the Census Bureau only include state boundaries. If we want to see counties in Georgia, we need to download and load the Census's county shapefiles (which we did above). We can then add a second `geom_sf()` layer for the counties.\n\nFirst we need to filter the county data to only include Georgia counties. The counties data doesn't include a column with the state name or state abbreviation, but it does include a column named `STATEFP`, which is the [state FIPS code](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standard_state_code). Looking at `lower_48` we can see that the state FIPS code for Georgia is 13, so we use that to filter.\n\n```{r get-ga-counties}\nga_counties <- us_counties %>% \n  filter(STATEFP == 13)\n```\n\nNow we can plot just the counties:\n\n```{r ga-counties-only}\nggplot() +\n  geom_sf(data = ga_counties) +\n  theme_void()\n```\n\nTechnically we can just draw the county boundaries instead of layer the state boundary + the counties, since the borders of the counties make up the border of the state. But there's an advantage to including both: we can use different aesthetics on each, like adding a thicker border on the state:\n\n```{r ga-counties-in-state}\nggplot() +\n  geom_sf(data = only_georgia_high, color = \"#EC8E55\", linewidth = 3) +\n  geom_sf(data = ga_counties, fill = \"#A5D46A\", color = \"white\") +\n  theme_void()\n```\n\nIt's also useful if we want to only show some counties, like metropolitan Atlanta:\n\n```{r atl-counties-in-state}\natl_counties <- ga_counties %>% \n  filter(NAME %in% c(\"Cherokee\", \"Clayton\", \"Cobb\", \"DeKalb\", \"Douglas\",\n                     \"Fayette\", \"Fulton\", \"Gwinnett\", \"Henry\", \"Rockdale\"))\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  geom_sf(data = atl_counties, fill = \"#A5D46A\", color = \"white\") +\n  theme_void()\n```\n\n## Plotting multiple shapefile layers when some are bigger than the parent shape\n\nSo far we've been able to filter out states and counties that we don't want to plot using `filter()`, which works because the shapefiles have geometry data for each state or county. But what if you're plotting stuff that doesn't follow state or county boundaries, like freeways, roads, rivers, or lakes? \n\nAt the beginning we loaded a shapefile for all large and small rivers in the US. Look at the first few rows of `rivers_na`:\n\n```{r head-river-small}\nhead(rivers_na)\n```\n\nThe first row is the whole Colorado river, which flows through seven states. We can't just use `filter()` to only select some parts of it based on states.\n\nHere's what happens if we combine our Georgia map with rivers and lakes:\n\n```{r ga-rivers-bad}\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  geom_sf(data = rivers_na) +\n  theme_void()\n```\n\nIt plots Georgia, and it's filled with orange, but it also plots every single river in North America. Oops.\n\nWe need to do a little GIS work to basically use `only_georgia` as a cookie cutter and keep only the rivers that are contained in the `only_georgia` boundaries. Fortunately, there's a function in the {sf} package that does this: `st_intersection()`. Feed it two shapefile datasets and it will select the parts of the second that fall within the boundaries of the first:\n\n```{r ga-cut-rivers-nope, error=TRUE}\nga_rivers_na <- st_intersection(only_georgia, rivers_na)\n```\n\nOh no! An error! It's complaining that the reference systems used in these two datasets don't match. We can check the CRS with `st_crs()`:\n\n```{r check-crs}\nst_crs(only_georgia)\nst_crs(rivers_na)\n```\n\nThe Georgia map uses EPSG:4269 ([or NAD83](https://epsg.io/4269)), while the rivers map uses EPSG:4326 (or [the GPS system of latitude and longitude](https://epsg.io/4326)). We need to convert one of them to make them match. It doesn't matter which one.\n\n```{r ga-cut-rivers-yep}\nonly_georgia_4326 <- only_georgia %>% \n  st_transform(crs = st_crs(\"EPSG:4326\"))\n\nga_rivers_na <- st_intersection(only_georgia_4326, rivers_na)\n```\n\nYou'll get an ominous warning, but you should be okay—it's just because flattening globes into flat planes is hard, and the cutting [might not be 100% accurate](https://github.com/r-spatial/sf/issues/493), but it'll be close enough for our mapping purposes.\n\nNow we can plot our state shape and the truncated rivers:\n\n```{r ga-rivers-good}\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  geom_sf(data = ga_rivers_na) +\n  theme_void()\n```\n\nHey! It worked! Let's put all the rivers and lakes on at once and make it a little more artsy. We'll use the high resolution Georgia map too, which conveniently already matches the CRS of the rivers and lakes:\n\n```{r ga-all-water, warning=FALSE, message=FALSE, fig.width=10, fig.height=6}\nga_rivers_na <- st_intersection(only_georgia_high, rivers_na)\nga_rivers_global <- st_intersection(only_georgia_high, rivers_global)\n\n# sf v1.0 changed how it handles shapefiles with spherical elements, which\n# apparently the lakes data uses. Currently when using st_intersection() and\n# other GIS-related functions, it breaks. This can be fixed by feeding the lakes\n# data to st_make_valid(), which does something fancy behind the scenes to make\n# it work. See this: https://github.com/r-spatial/sf/issues/1649#issuecomment-853279986\nga_lakes <- st_intersection(only_georgia_high, st_make_valid(lakes))\n\nggplot() +\n  geom_sf(data = only_georgia_high, \n          color = \"black\", linewidth = 0.1, fill = \"black\") +\n  geom_sf(data = ga_rivers_global, linewidth = 0.3, color = \"grey80\") +\n  geom_sf(data = ga_rivers_na, linewidth = 0.15, color = \"grey80\") +\n  geom_sf(data = ga_lakes, linewidth = 0.3, fill = \"grey80\", color = NA) +\n  coord_sf(crs = st_crs(\"EPSG:4326\")) +  # NAD83\n  theme_void()\n```\n\nHeck yeah. That's a great map. This is basically what [Kieran Healy did here](https://kieranhealy.org/prints/rivers/), but he used [even more detailed shapefiles from the US Geological Survey](https://www.usgs.gov/core-science-systems/ngp/national-hydrography).\n\n\n## Plotting schools in Georgia\n\nShapefiles are not limited to just lines and areas—they can also contain points. I made a free account at the Georgia GIS Clearinghouse, searched for \"schools\" and found a shapefile of all the K–12 schools in 2009. [This is the direct link to the page](https://data.georgiaspatial.org/index.asp?body=preview&dataId=41516), but it only works if you're logged in to their system. [This is the official metadata for the shapefile](https://data.georgiaspatial.org/data/statewide/other/schools_2009.html), which you can see if you're not logged in, but you can't download anything. It's a dumb system and other states are a lot better at offering their GIS data (like, [here's a shapefile of all of Utah's schools and libraries](https://gis.utah.gov/data/society/schools-libraries/) as of 2017, publicly accessible without an account).\n\nWe loaded the shapefile up at the top, but now let's look at it:\n\n```{r}\nhead(ga_schools)\n```\n\nWe have a bunch of columns like `GRADES` that has a list of what grades are included in the school, and `TOTAL`, which I'm guessing is the number of students. Let's map it!\n\nIf we add a `geom_sf()` layer just for `ga_schools`, it'll plot a bunch of points:\n\n```{r plot-ga-schools-initial}\nggplot() +\n  geom_sf(data = ga_schools)\n```\n\nOne of these rows is wildly miscoded and ended up Indonesia! If you sort by the `geometry` column in RStudio, you'll see that it's most likely Allatoona High School in Cobb County (id = 22097). The coordinates are different from all the others, and it has no congressional district information. Let's remove it.\n\n```{r plot-ga-schools-fixed}\nga_schools_fixed <- ga_schools %>% \n  filter(ID != 22097)\n\nggplot() +\n  geom_sf(data = ga_schools_fixed)\n```\n\nThat's better. However, all we're plotting now are the points—we've lost the state and/or county boundaries. Let's include those:\n\n```{r plot-ga-schools-borders}\nggplot() +\n  geom_sf(data = only_georgia_high) +\n  geom_sf(data = ga_schools_fixed) +\n  theme_void()\n```\n\nWe're getting closer. We have some issues with overplotting, so let's shrink the points down and make them a little transparent:\n\n```{r plot-ga-schools-shrunk}\nggplot() +\n  geom_sf(data = only_georgia_high) +\n  geom_sf(data = ga_schools_fixed, size = 0.5, alpha = 0.5) +\n  theme_void()\n```\n\nNeat. One last thing we can do is map the `TOTAL` column to the color aesthetic and color the points by how many students attend each school:\n\n```{r plot-ga-schools-color}\nggplot() +\n  geom_sf(data = only_georgia_high) +\n  geom_sf(data = ga_schools_fixed, aes(color = TOTAL), size = 0.75, alpha = 0.5) +\n  scale_color_viridis_c() +\n  theme_void()\n```\n\nMost schools appear to be under 1,000 students, except for a cluster in Gwinnett County north of Atlanta. Its high schools have nearly 4,000 students each!\n\n```{r show-biggest-schools}\nga_schools_fixed %>% \n  select(COUNTY, SCHOOLNAME, TOTAL) %>% \n  arrange(desc(TOTAL)) %>% \n  head()\n```\n\n\n## Making your own geocoded data\n\nSo, plotting shapefiles with `geom_sf()` is magical because {sf} deals with all of the projection issues for us automatically and it figures out how to plot all the latitude and longitude data for us automatically. But lots of data *doesn't* some as shapefiles. The [rats data from mini project 1](/assignment/01-mini-project.qmd), for instance, has two columns indicating the latitude and longitude of each rat sighting, but those are stored as just numbers. If we try to use `geom_sf()` with the rat data, it won't work. We need that magical `geometry` column.\n\nFortunately, if we have latitude and longitude information, we can make our own `geometry` column. \n\nLet's say we want to mark some cities on our map of Georgia. We can make a mini dataset using `tribble()`. I found these points from Google Maps: right click anywhere in Google Maps, select \"What's here?\", and you'll see the exact coordinates for that spot.\n\n```{r mini-cities}\nga_cities <- tribble(\n  ~city, ~lat, ~long,\n  \"Atlanta\", 33.748955, -84.388099,\n  \"Athens\", 33.950794, -83.358884,\n  \"Savannah\", 32.113192, -81.089350\n)\nga_cities\n```\n\nThis is just a normal dataset, and the `lat` and `long` columns are just numbers. R doesn't know that those are actually geographic coordinates. This is similar to the rats data, or any other data that has columns for latitude and longitude.\n\nWe can convert those two columns to the magic `geometry` column with the `st_as_sf()` function. We have to define two things in the function: which coordinates are the longitude and latitude, and what CRS the coordinates are using. Google Maps uses [EPSG:4326, or the GPS system](http://epsg.io/4326), so we specify that:\n\n```{r mini-cities-convert}\nga_cities_geometry <- ga_cities %>% \n  st_as_sf(coords = c(\"long\", \"lat\"), crs = st_crs(\"EPSG:4326\"))\nga_cities_geometry\n```\n\nThe longitude and latitude columns are gone now, and we have a single magical `geometry` column. That means we can plot it with `geom_sf()`:\n\n```{r ga-with-cities}\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  geom_sf(data = ga_cities_geometry, size = 3) +\n  theme_void()\n```\n\nWe can use `geom_sf_label()` (or `geom_sf_text()`) to add labels in the correct locations too. It will give you a warning, but you can ignore it—again, it's complaining that the positioning might not be 100% accurate because of issues related to taking a globe and flattening it. It's fine.\n\n```{r ga-with-cities-text, warning=FALSE, fig.width=10, fig.height=6}\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  geom_sf(data = ga_cities_geometry, size = 3) +\n  geom_sf_label(data = ga_cities_geometry, aes(label = city),\n                nudge_y = 0.2) +\n  theme_void()\n```\n\n## Automatic geocoding by address\n\nUsing `st_as_sf()` is neat when you have latitude and longitude data already, but what if you have a list of addresses or cities instead, with no fancy geographic information? It's easy enough to right click on Google Maps, but you don't really want to do that hundreds of times for large-scale data.\n\nFortunately there are a bunch of different online geocoding services that return GIS data for addresses and locations that you feed them, like magic. \n\nThe easiest way to use any of these services is to use the [{tidygeocoder}](https://jessecambon.github.io/tidygeocoder/) package, which connects with all these different free and paid services (run `?geo` in R for complete details):\n\n- `\"osm\"`: OpenStreetMap through [Nominatim](https://nominatim.org/). **FREE**.\n- `\"census\"`: [US Census](https://geocoding.geo.census.gov/). Geographic coverage is limited to the United States. **FREE**.\n- `\"arcgis\"`: [ArcGIS](https://developers.arcgis.com/rest/geocode/api-reference/overview-world-geocoding-service.htm). **FREE** and paid.\n- `\"geocodio\"`: [Geocodio](https://www.geocod.io/). Geographic coverage is limited to the United States and Canada. An API key must be stored in `\"GEOCODIO_API_KEY\"`.\n- `\"iq\"`: [Location IQ](https://locationiq.com/). An API key must be stored in `\"LOCATIONIQ_API_KEY\"`.\n- `\"google\"`: [Google](https://developers.google.com/maps/documentation/geocoding/overview). An API key must be stored in `\"GOOGLEGEOCODE_API_KEY\"`.\n- `\"opencage\"`: [OpenCage](https://opencagedata.com/). An API key must be stored in `\"OPENCAGE_KEY\"`.\n- `\"mapbox\"`: [Mapbox](https://docs.mapbox.com/api/search/). An API key must be stored in `\"MAPBOX_API_KEY\"`.\n- `\"here\"`: [HERE](https://developer.here.com/products/geocoding-and-search). An API key must be stored in `\"HERE_API_KEY\"`.\n- `\"tomtom\"`: [TomTom](https://developer.tomtom.com/search-api/search-api-documentation/geocoding). An API key must be stored in `\"TOMTOM_API_KEY\"`.\n- `\"mapquest\"`: [MapQuest](https://developer.mapquest.com/documentation/geocoding-api/). An API key must be stored in `\"MAPQUEST_API_KEY\"`.\n- `\"bing\"`: [Bing](https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/). An API key must be stored in `\"BINGMAPS_API_KEY\"`.\n\nNot all services work equally well, and the free ones have rate limits (like, don't try to geocode a million rows of data with the US Census), so you'll have to play around with different services. You can also provide a list of services and {tidygeocoder} will cascade through them—if it can't geocode an address with OpenStreetMap, it can move on to the Census, then ArcGIS, and so on. You need to set the `cascade_order` argument in `geocode()` for this to work.\n\nLet's make a little dataset with some addresses to geocode: \n\n```{r build-some-addresses}\nsome_addresses <- tribble(\n  ~name,             ~address,\n  \"The White House\", \"1600 Pennsylvania Ave NW, Washington, DC\",\n  \"The Andrew Young School of Policy Studies\", \"55 Park Place SE, Atlanta, GA 30303\"\n)\n\nsome_addresses\n```\n\nTo geocode these addresses, we can feed this data into `geocode()` and tell it to use the `address` column. We'll use the Census geocoding system for fun (surely they know where the White House is):\n\n```{r geocode-fake, eval=FALSE}\nlibrary(tidygeocoder)\n\ngeocoded_addresses <- some_addresses %>% \n  geocode(address, method = \"census\")\n\ngeocoded_addresses\n```\n\n```{r show-geocode, echo=FALSE}\ngeocoded_addresses %>% \n  select(name, lat, long)\n```\n\nIt worked!\n\nThose are just numbers, though, and not the magical `geometry` column, so we need to use `st_as_sf()` to convert them to actual GIS data.\n\n```{r st-as-sf-geocoded}\naddresses_geometry <- geocoded_addresses %>% \n  st_as_sf(coords = c(\"long\", \"lat\"), crs = st_crs(\"EPSG:4326\"))\n\naddresses_geometry %>% select(-address)\n```\n\nLet's plot these on a US map:\n\n```{r plot-geocoded-cities}\nggplot() + \n  geom_sf(data = lower_48, fill = \"#192DA1\", color = \"white\", linewidth = 0.25) +\n  geom_sf(data = addresses_geometry, size = 5, color = \"#FF851B\") +\n  # Albers uses meters as its unit of measurement, so we need to nudge these\n  # labels up by a lot. I only settled on 175,000 here after a bunch of trial\n  # and error, adding single zeroes and rerunning the plot until the labels\n  # moved. 175,000 meters = 108.74 miles\n  geom_sf_label(data = addresses_geometry, aes(label = name),\n                size = 4, fill = \"#FF851B\", nudge_y = 175000) + \n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n## Plotting other data on maps\n\nSo far we've just plotted whatever data the shapefile creators decided to include and publish in their data. But what if you want to visualize some other variable on a map? We can do this by combining our shapefile data with any other kind of data, as long as the two have a shared column. For instance, we can make a choropleth map of life expectancy with data from the World Bank.\n\nFirst, let's grab some data from the World Bank for just 2015:\n\n```{r get-wdi, eval=FALSE}\nlibrary(WDI)  # For getting data from the World Bank\n\nindicators <- c(life_expectancy = \"SP.DYN.LE00.IN\")  # Life expectancy\n\nwdi_raw <- WDI(country = \"all\", indicators, extra = TRUE, \n               start = 2015, end = 2015)\n```\n\n```{r load-wdi, include=FALSE}\nwdi_raw <- read_csv(here::here(wdi_path))\n```\n\nLet's see what we got:\n\n```{r head-wdi-raw}\nhead(wdi_raw)\n```\n\nWe have a bunch of columns here, but we care about two in particular: life expectancy, and the ISO3 code. This three-letter code is a standard system for identifying countries ([see the full list here](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)), and that column will let us combine this World Bank data with the global shapefile, which also has a column for the ISO3 code.\n\n::: {.callout-note}\n### World capitals\n\nWe also have columns for the latitude and longitude for each capital, so we could theoretically convert those to a `geometry` column with `st_as_sf()` and plot world capitals, which would be neat, but we won't do that now.\n:::\n\nLet's clean up the WDI data by shrinking it down substantially so we only join the one `life_expectancy` column that we care about:\n\n```{r clean-wdi}\nwdi_clean_small <- wdi_raw %>% \n  select(life_expectancy, iso3c)\nwdi_clean_small\n```\n\nNext we need to merge this tiny dataset into the `world_map_sans_antarctica` shapefile data we were using earlier. To do this we'll use a function named `left_join()`. We feed two data frames into `left_join()`, and R will keep all the rows from the first and include all the columns from both the first and the second wherever the two datasets match with one specific column. That's wordy and weird—[stare at this animation here](https://github.com/gadenbuie/tidyexplain#left-join) for a few seconds to see what's really going to happen. We're essentially going to append the World Bank data to the end of the world shapefiles and line up rows that have matching ISO3 codes. The ISO3 column is named `ISO_A3` in the shapefile data, and it's named `iso3c` in the WDI data, so we tell `left_join()` that those are the same column:\n\n```{r combine-map-wdi}\nworld_map_with_life_expectancy <- world_sans_antarctica %>% \n  left_join(wdi_clean_small, by = c(\"ISO_A3\" = \"iso3c\"))\n```\n\nIf you look at this dataset in RStudio now and look at the last column, you'll see the WDI life expectancy right next to the magic `geometry` column.\n\nWe technically didn't need to shrink the WDI data down to just two columns—had we left everything else, all the WDI columns would have come over to the `world_sans_antarctica`, including columns for region and income level, etc. But I generally find it easier and cleaner to only merge in the columns I care about instead of making massive datasets with a billion extra columns.\n\nNow that we have a column for life expectancy, we can map it to the fill aesthetic and fill each country by 2015 life expectancy:\n\n```{r world-life-exp-2015, fig.width=10, fig.height=6}\nggplot() + \n  geom_sf(data = world_map_with_life_expectancy, \n          aes(fill = life_expectancy),\n          linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  scale_fill_viridis_c(option = \"viridis\") +\n  labs(fill = \"Life expectancy\") +\n  theme_void() +\n  theme(legend.position = \"bottom\")\n```\n\nVoila! Global life expectancy in 2015!\n\n---\n\n::: {.callout-tip}\n### France and Norway\n\nSharp-eyed readers will notice that France and Norway are grayed out because they're missing data. That's because the `ISO_A3` code in the Natural Earth data is missing for both France and Norway for whatever reason, so the WDI data didn't merge with those rows. To fix that, we can do some manual recoding before joining in the WDI data.\n:::\n\n```{r world-life-exp-2015-fixed, fig.width=10, fig.height=6}\nworld_sans_antarctica_fixed <- world_sans_antarctica %>% \n  mutate(ISO_A3 = case_when(\n    # If the country name is Norway or France, redo the ISO3 code\n    ADMIN == \"Norway\" ~ \"NOR\",\n    ADMIN == \"France\" ~ \"FRA\",\n    # Otherwise use the existing ISO3 code\n    TRUE ~ ISO_A3\n  )) %>% \n  left_join(wdi_clean_small, by = c(\"ISO_A3\" = \"iso3c\"))\n\nggplot() + \n  geom_sf(data = world_sans_antarctica_fixed, \n          aes(fill = life_expectancy),\n          linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  scale_fill_viridis_c(option = \"viridis\") +\n  labs(fill = \"Life expectancy\") +\n  theme_void() +\n  theme(legend.position = \"bottom\")\n```\n","srcMarkdownNoYaml":"\n\n```{r load-targets, include=FALSE}\nwithr::with_dir(here::here(), {\n  geocoded_path <- targets::tar_read(data_geocoded)\n  wdi_path <- targets::tar_read(data_wdi_lifeexp)\n})\n```\n\n## Shapefiles\n\nShapefiles are special types of data that include information about geography, such as points (latitude, longitude), paths (a bunch of connected latitudes and longitudes) and areas (a bunch of connected latitudes and longitudes that form a complete shape). Nowadays, most government agencies provide shapefiles for their jurisdictions. For global mapping data, you can use the Natural Earth project:\n\n- [Natural Earth](https://www.naturalearthdata.com/)\n- [US Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html)\n- [Georgia GIS Clearinghouse](https://data.georgiaspatial.org/) (requires a free account; the interface is *incredibly* clunky)\n- [Atlanta Regional Council](https://opendata.atlantaregional.com/)\n- [Fulton County GIS Portal](https://gisdata.fultoncountyga.gov/)\n- [City of Atlanta, Department of City Planning](https://dcp-coaplangis.opendata.arcgis.com/)\n\n\n## Projections and coordinate reference systems\n\nAs you read in this week's readings, projections matter a lot for maps. You can convert your geographic data between different coordinate systems (or projections) fairly easily with {sf}. You can use `coord_sf(crs = st_crs(\"XXXX\"))` to convert coordinate reference systems (CRS) as you plot, or use `st_transform()` to convert data frames to a different CRS.\n\n::: {.callout-note}\n### Not 100% correct\n\nTECHNICALLY coordinate systems and projection systems [are different things](https://gis.stackexchange.com/a/149751/56265), but I'm not a geographer and I don't care that much about the nuance.\n:::\n\nThere are standard indexes of more than 4,000 of these projections (!!!) at [epsg.io](https://epsg.io/). \n\n**Super important**: When using these projections, you need to specify both the projection catalog (ESRI or EPSG; [see here for the difference](https://gis.stackexchange.com/a/169211/56265)) and the projection number, separated by a colon (e.g. \"`ESRI:54030`\"). Fortunately [epsg.io](http://epsg.io/) makes this super easy: go to the epsg.io page for the projection you want to use and the page title will have the correct name. \n\nHere are some common ones:\n\n- [ESRI:54002](http://epsg.io/54002): Equidistant cylindrical projection for the world[^gall-peters]\n- [EPSG:3395](http://epsg.io/3395): Mercator projection for the world\n- [ESRI:54008](http://epsg.io/54008): Sinusoidal projection for the world\n- [ESRI:54009](http://epsg.io/54009): Mollweide projection for the world\n- [ESRI:54030](http://epsg.io/54030): Robinson projection for the world (This is my favorite world projection.)\n- [EPSG:4326](http://epsg.io/4326): WGS 84: DOD GPS coordinates (standard −180 to 180 system)\n- [EPSG:4269](http://epsg.io/4269): NAD 83: Relatively common projection for North America\n- [ESRI:102003](https://epsg.io/102003): Albers projection specifically for the contiguous United States\n\n[^gall-peters]: This is essentially the [Gall-Peters projection](https://en.wikipedia.org/wiki/Gall%E2%80%93Peters_projection) from [the West Wing clip](https://www.youtube.com/watch?v=vVX-PrBRtTY).\n\nAlternatively, instead of using these index numbers, you can use any of the names listed [here](https://proj.org/operations/projections/index.html), such as:\n\n- `\"+proj=merc\"`: Mercator\n- `\"+proj=robin\"`: Robinson\n- `\"+proj=moll\"`: Mollweide \n- `\"+proj=aeqd\"`: Azimuthal Equidistant\n- `\"+proj=cass\"`: Cassini-Soldner\n\n\n## Shapefiles to download\n\nI use a lot of different shapefiles in this example. To save you from having to go find and download each individual one, you can download this zip file:\n\n- [{{< fa file-archive >}} `shapefiles.zip`](/files/data/external_data/shapefiles.zip)\n\nUnzip this and put all the contained folders in a folder named `data` if you want to follow along. **You don't need to follow along!**\n\nYour project should be structured like this:\n\n```default\nyour-project-name\\\n  some-name.Rmd\n  your-project-name.Rproj\n  data\\\n    cb_2022_us_county_5m\\\n      ...\n      cb_2022_us_county_5m.shp\n      ...\n    cb_2022_us_state_20m\\\n    ne_10m_admin_1_states_provinces\\\n    ne_10m_lakes\\\n    ne_10m_rivers_lake_centerlines\\\n    ne_10m_rivers_north_america\\\n    ne_110m_admin_0_countries\\\n    schools_2009\\\n```\n\nThese shapefiles all came from these sources:\n\n- {{< fa map >}} **World map**: [110m \"Admin 0 - Countries\" from Natural Earth](https://www.naturalearthdata.com/downloads/110m-cultural-vectors/)\n- {{< fa map >}} **US states**: [20m 2022 state boundaries from the US Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html)\n- {{< fa map >}} **US counties**: [5m 2022 county boundaries from the US Census Bureau](https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html)\n- {{< fa map >}} **US states high resolution**: [10m \"Admin 1 – States, Provinces\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/)\n- {{< fa map >}} **Global rivers**: [10m \"Rivers + lake centerlines\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/)\n- {{< fa map >}} **North American rivers**: [10m \"Rivers + lake centerlines, North America supplement\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-physical-vectors/)\n- {{< fa map >}} **Global lakes**: [10m \"Lakes + Reservoirs\" from Natural Earth](https://www.naturalearthdata.com/downloads/10m-physical-vectors/)\n- {{< fa map >}} **Georgia K–12 schools, 2009**: [\"Georgia K-12 Schools\" from the Georgia Department of Education](https://data.georgiaspatial.org/index.asp?body=preview&dataId=41516) *(you must be logged in to access this)*\n\n\n## Live coding example\n\n<div class=\"ratio ratio-16x9\">\n<iframe src=\"https://www.youtube.com/embed/Opzwtegvuv4\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\"></iframe>\n</div>\n\n\n::: {.callout-important}\n### Slight differences from the video\n\nThis is a slightly cleaned up version of the code from the video.\n:::\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(fig.width = 6, fig.height = 3.6, fig.align = \"center\", collapse = TRUE)\nset.seed(1234)\noptions(\"digits\" = 2, \"width\" = 150)\n```\n\n## Load and look at data\n\nFirst we'll load the libraries we're going to use:\n\n```{r load-libraries, message=FALSE, warning=FALSE}\nlibrary(tidyverse)  # For ggplot, dplyr, and friends\nlibrary(sf)         # For GIS magic\n```\n\nNext we'll load all the different shapefiles we downloaded using `read_sf()`: \n\n```{r load-shapefiles-fake, eval=FALSE}\n# Download \"Admin 0 – Countries\" from\n# https://www.naturalearthdata.com/downloads/110m-cultural-vectors/\nworld_map <- read_sf(\"data/ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp\")\n\n# Download cb_2022_us_state_20m.zip under \"States\" from\n# https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html\nus_states <- read_sf(\"data/cb_2022_us_state_20m/cb_2022_us_state_20m.shp\")\n\n# Download cb_2022_us_county_5m.zip under \"County\" from\n# https://www.census.gov/geographies/mapping-files/time-series/geo/cartographic-boundary.html\nus_counties <- read_sf(\"data/cb_2022_us_county_5m/cb_2022_us_county_5m.shp\")\n\n# Download \"Admin 1 – States, Provinces\" from\n# https://www.naturalearthdata.com/downloads/10m-cultural-vectors/\nus_states_hires <- read_sf(\"data/ne_10m_admin_1_states_provinces/ne_10m_admin_1_states_provinces.shp\")\n\n# Download \"Rivers + lake centerlines\" from\n# https://www.naturalearthdata.com/downloads/10m-physical-vectors/\nrivers_global <- read_sf(\"data/ne_10m_rivers_lake_centerlines/ne_10m_rivers_lake_centerlines.shp\")\n\n# Download \"Rivers + lake centerlines, North America supplement\" from\n# https://www.naturalearthdata.com/downloads/10m-physical-vectors/\nrivers_na <- read_sf(\"data/ne_10m_rivers_north_america/ne_10m_rivers_north_america.shp\")\n\n# Download \"Lakes + Reservoirs\" from\n# https://www.naturalearthdata.com/downloads/10m-physical-vectors/\nlakes <- read_sf(\"data/ne_10m_lakes/ne_10m_lakes.shp\")\n\n# Download from https://data.georgiaspatial.org/index.asp?body=preview&dataId=41516\n# after creating an account and logging in\nga_schools <- read_sf(\"data/schools_2009/DOE Schools 2009.shp\")\n```\n\n```{r load-shapefiles-real, include=FALSE}\nworld_map <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                \"ne_110m_admin_0_countries\", \n                                \"ne_110m_admin_0_countries.shp\"))\n\nus_states <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                \"cb_2022_us_state_20m\",\n                                \"cb_2022_us_state_20m.shp\"))\n\nus_states_hires <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                      \"ne_10m_admin_1_states_provinces\",\n                                      \"ne_10m_admin_1_states_provinces.shp\"))\n\nus_counties <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                  \"cb_2022_us_county_5m\",\n                                  \"cb_2022_us_county_5m.shp\"))\n\nrivers_global <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                    \"ne_10m_rivers_lake_centerlines\",\n                                    \"ne_10m_rivers_lake_centerlines.shp\"))\n\nrivers_na <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                \"ne_10m_rivers_north_america\",\n                                \"ne_10m_rivers_north_america.shp\"))\n\nlakes <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                            \"ne_10m_lakes\", \"ne_10m_lakes.shp\"))\n\nga_schools <- read_sf(here::here(\"files\", \"data\", \"external_data\", \"maps\",\n                                 \"schools_2009\", \"DOE Schools 2009.shp\"))\n\ngeocoded_addresses <- read_csv(here::here(geocoded_path))\n```\n\n## Basic plotting\n\nIf you look at the `world_map` dataset in RStudio, you'll see it's just a standard data frame with `r nrow(world_map)` rows and `r ncol(world_map)` columns. The last column is the magical `geometry` column with the latitude/longitude details for the borders for every country. RStudio only shows you 50 columns at a time in the RStudio viewer, so you'll need to move to the next page of columns with the » button in the top left corner.\n\nBecause this is just a data frame, we can do all our normal dplyr things to it. Let's get rid of Antarctica, since it takes up a big proportion of the southern hemisphere:\n\n```{r world-sans-ata}\nworld_sans_antarctica <- world_map %>% \n  filter(ISO_A3 != \"ATA\")\n```\n\nReady to plot a map? Here's all you need to do:\n\n```{r map-super-basic}\nggplot() + \n  geom_sf(data = world_sans_antarctica)\n```\n\nIf you couldn't tell from the lecture, I'm completely blown away by how amazingly easy this every time I plot a map :)\n\nBecause this a regular ggplot geom, all our regular aesthetics and themes and everything work:\n\n```{r map-super-basic-filled}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  theme_void()\n```\n\nThe Natural Earth dataset happens to come with some columns with a coloring scheme with 7–13 colors (`MAPCOLOR7`, `MAPCOLOR9`, etc.) so that no countries with a shared border share a color. We can fill by that column:\n\n```{r map-super-basic-filled-7}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          aes(fill = as.factor(MAPCOLOR7)),\n          color = \"#401D16\", linewidth = 0.25) +\n  scale_fill_viridis_d(option = \"plasma\") +\n  guides(fill = \"none\") +\n  theme_void()\n```\n\n## World map with different projections\n\nChanging projections is trivial: add a `coord_sf()` layer where you specify the CRS you want to use.\n\nHere's Robinson (yay):\n\n```{r map-basic-robinson}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  # Or use the name instead of the number\n  # coord_sf(crs = \"+proj=robin\")\n  theme_void()\n```\n\nHere's sinusoidal:\n\n```{r map-basic-sinusoidal}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54008\")) +  # Sinusoidal\n  theme_void()\n```\n\nAnd here's Mercator (ewww):\n\n```{r map-basic-mercator}\nggplot() + \n  geom_sf(data = world_sans_antarctica, \n          fill = \"#669438\", color = \"#32481B\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"EPSG:3395\")) +  # Mercator\n  # Or use the name instead of the number\n  # coord_sf(crs = \"+proj=merc\")\n  theme_void()\n```\n\n## US map with different projections\n\nThis same process works for any shapefile. The map of the US can also be projected differently—two common projections are NAD83 and Albers. We'll take the `us_states` dataset, remove Alaska, Hawaii, and Puerto Rico (they're so far from the rest of the lower 48 states that they make an unusable map—see the next section for a way to include them), and plot it.\n\n```{r us-nad83}\nlower_48 <- us_states %>% \n  filter(!(NAME %in% c(\"Alaska\", \"Hawaii\", \"Puerto Rico\")))\n\nggplot() + \n  geom_sf(data = lower_48, fill = \"#192DA1\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"EPSG:4269\")) +  # NAD83\n  theme_void()\n```\n\n```{r us-albers}\nggplot() + \n  geom_sf(data = lower_48, fill = \"#192DA1\", color = \"white\", linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n## US map with non-continguous parts\n\nPlotting places like Alaska, Hawaii, and Puerto Rico gets a little tricky since they're far away from the contiguous 48 states. There's an easy way to handle it though!\n\nFirst, there's a package named [{tigris}](https://github.com/walkerke/tigris) that provides a neat interface for working with spatial data from the [US Census's TIGER shapefiles](https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.html). In addition to providing a ton of functions for getting shapefiles for states, counties, voting districts, Tribal areas, military bases, and dozens of other things, {tigris} has a `shift_geometry()` function that will change the coordinates for Alaska, Hawaii, and Puerto Rico so that they end up in Mexico and the Gulf of Mexico.\n\n\n```{r tigris-shifting, warning=FALSE, message=FALSE}\nlibrary(tigris)\n\n# This is the Census shapefile we loaded earlier. Note how we're not filtering\n# out AK, HI, and PR now\nus_states_shifted <- us_states %>% \n  shift_geometry()  # Move AK, HI, and PR around\n\nggplot() +\n  geom_sf(data = us_states_shifted) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\nThe `shift_geometry()` function should work on any shapefile. What if you have a shapefile with the coordinates of all public libraries in Alaska? Those will use the actual coordinates, not the shifted-to-Mexico coordinates. Feed that data to `shift_geometry()` and it should translate any coordinates you have in Alaska, Hawaii, and Puerto Rico to the Mexico area so they'll plot correctly.\n\n`shift_geometry()` has an optional `position` argument that lets you control where the non-contiguous states go. By default they'll go below the continental US (`position = \"below\"`), but you can also use `position = \"outside\"` to place them more in relation to where they are in real life:\n\n```{r tigris-shifting-alt}\nus_states_shifted <- us_states %>% \n  shift_geometry(position = \"outside\")\n\nggplot() +\n  geom_sf(data = us_states_shifted) +\n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n\n## Individual states\n\nAgain, because these shapefiles are really just fancy data frames, we can filter them with normal dplyr functions. Let's plot just Georgia:\n\n```{r georgia-only}\nonly_georgia <- lower_48 %>% \n  filter(NAME == \"Georgia\")\n\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  theme_void()\n```\n\nWe can also use a different projection. If we look at [epsg.io](http://epsg.io/), there's [a version of NAD83 that's focused specifically on Georgia](http://epsg.io/2239-1713). \n\n```{r georgia-only-projection}\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  theme_void() +\n  coord_sf(crs = st_crs(\"EPSG:2239\"))  # NAD83 focused on Georgia\n```\n\nThere's one small final issue though: we're missing all the Atlantic islands in the southeast like Cumberland Island and Amelia Island. That's because we're using the Census's low resolution (20m) data. That's fine for the map of the whole country, but if we're looking at a single state, we probably want better detail in the borders. We can use the Census's high resolution (500k) data, but even then it doesn't include the islands for whatever reason, but [Natural Earth has high resolution US state data](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-1-states-provinces/) that *does* have the islands, so we can use that:\n\n```{r georgia-only-hires}\nonly_georgia_high <- us_states_hires %>% \n  filter(iso_3166_2 == \"US-GA\")\n\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  theme_void() +\n  coord_sf(crs = st_crs(\"EPSG:2239\"))  # NAD83 focused on Georgia\n```\n\nPerfect.\n\n\n## Plotting multiple shapefile layers\n\nThe state shapefiles from the Census Bureau only include state boundaries. If we want to see counties in Georgia, we need to download and load the Census's county shapefiles (which we did above). We can then add a second `geom_sf()` layer for the counties.\n\nFirst we need to filter the county data to only include Georgia counties. The counties data doesn't include a column with the state name or state abbreviation, but it does include a column named `STATEFP`, which is the [state FIPS code](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standard_state_code). Looking at `lower_48` we can see that the state FIPS code for Georgia is 13, so we use that to filter.\n\n```{r get-ga-counties}\nga_counties <- us_counties %>% \n  filter(STATEFP == 13)\n```\n\nNow we can plot just the counties:\n\n```{r ga-counties-only}\nggplot() +\n  geom_sf(data = ga_counties) +\n  theme_void()\n```\n\nTechnically we can just draw the county boundaries instead of layer the state boundary + the counties, since the borders of the counties make up the border of the state. But there's an advantage to including both: we can use different aesthetics on each, like adding a thicker border on the state:\n\n```{r ga-counties-in-state}\nggplot() +\n  geom_sf(data = only_georgia_high, color = \"#EC8E55\", linewidth = 3) +\n  geom_sf(data = ga_counties, fill = \"#A5D46A\", color = \"white\") +\n  theme_void()\n```\n\nIt's also useful if we want to only show some counties, like metropolitan Atlanta:\n\n```{r atl-counties-in-state}\natl_counties <- ga_counties %>% \n  filter(NAME %in% c(\"Cherokee\", \"Clayton\", \"Cobb\", \"DeKalb\", \"Douglas\",\n                     \"Fayette\", \"Fulton\", \"Gwinnett\", \"Henry\", \"Rockdale\"))\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  geom_sf(data = atl_counties, fill = \"#A5D46A\", color = \"white\") +\n  theme_void()\n```\n\n## Plotting multiple shapefile layers when some are bigger than the parent shape\n\nSo far we've been able to filter out states and counties that we don't want to plot using `filter()`, which works because the shapefiles have geometry data for each state or county. But what if you're plotting stuff that doesn't follow state or county boundaries, like freeways, roads, rivers, or lakes? \n\nAt the beginning we loaded a shapefile for all large and small rivers in the US. Look at the first few rows of `rivers_na`:\n\n```{r head-river-small}\nhead(rivers_na)\n```\n\nThe first row is the whole Colorado river, which flows through seven states. We can't just use `filter()` to only select some parts of it based on states.\n\nHere's what happens if we combine our Georgia map with rivers and lakes:\n\n```{r ga-rivers-bad}\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  geom_sf(data = rivers_na) +\n  theme_void()\n```\n\nIt plots Georgia, and it's filled with orange, but it also plots every single river in North America. Oops.\n\nWe need to do a little GIS work to basically use `only_georgia` as a cookie cutter and keep only the rivers that are contained in the `only_georgia` boundaries. Fortunately, there's a function in the {sf} package that does this: `st_intersection()`. Feed it two shapefile datasets and it will select the parts of the second that fall within the boundaries of the first:\n\n```{r ga-cut-rivers-nope, error=TRUE}\nga_rivers_na <- st_intersection(only_georgia, rivers_na)\n```\n\nOh no! An error! It's complaining that the reference systems used in these two datasets don't match. We can check the CRS with `st_crs()`:\n\n```{r check-crs}\nst_crs(only_georgia)\nst_crs(rivers_na)\n```\n\nThe Georgia map uses EPSG:4269 ([or NAD83](https://epsg.io/4269)), while the rivers map uses EPSG:4326 (or [the GPS system of latitude and longitude](https://epsg.io/4326)). We need to convert one of them to make them match. It doesn't matter which one.\n\n```{r ga-cut-rivers-yep}\nonly_georgia_4326 <- only_georgia %>% \n  st_transform(crs = st_crs(\"EPSG:4326\"))\n\nga_rivers_na <- st_intersection(only_georgia_4326, rivers_na)\n```\n\nYou'll get an ominous warning, but you should be okay—it's just because flattening globes into flat planes is hard, and the cutting [might not be 100% accurate](https://github.com/r-spatial/sf/issues/493), but it'll be close enough for our mapping purposes.\n\nNow we can plot our state shape and the truncated rivers:\n\n```{r ga-rivers-good}\nggplot() +\n  geom_sf(data = only_georgia, fill = \"#EC8E55\") +\n  geom_sf(data = ga_rivers_na) +\n  theme_void()\n```\n\nHey! It worked! Let's put all the rivers and lakes on at once and make it a little more artsy. We'll use the high resolution Georgia map too, which conveniently already matches the CRS of the rivers and lakes:\n\n```{r ga-all-water, warning=FALSE, message=FALSE, fig.width=10, fig.height=6}\nga_rivers_na <- st_intersection(only_georgia_high, rivers_na)\nga_rivers_global <- st_intersection(only_georgia_high, rivers_global)\n\n# sf v1.0 changed how it handles shapefiles with spherical elements, which\n# apparently the lakes data uses. Currently when using st_intersection() and\n# other GIS-related functions, it breaks. This can be fixed by feeding the lakes\n# data to st_make_valid(), which does something fancy behind the scenes to make\n# it work. See this: https://github.com/r-spatial/sf/issues/1649#issuecomment-853279986\nga_lakes <- st_intersection(only_georgia_high, st_make_valid(lakes))\n\nggplot() +\n  geom_sf(data = only_georgia_high, \n          color = \"black\", linewidth = 0.1, fill = \"black\") +\n  geom_sf(data = ga_rivers_global, linewidth = 0.3, color = \"grey80\") +\n  geom_sf(data = ga_rivers_na, linewidth = 0.15, color = \"grey80\") +\n  geom_sf(data = ga_lakes, linewidth = 0.3, fill = \"grey80\", color = NA) +\n  coord_sf(crs = st_crs(\"EPSG:4326\")) +  # NAD83\n  theme_void()\n```\n\nHeck yeah. That's a great map. This is basically what [Kieran Healy did here](https://kieranhealy.org/prints/rivers/), but he used [even more detailed shapefiles from the US Geological Survey](https://www.usgs.gov/core-science-systems/ngp/national-hydrography).\n\n\n## Plotting schools in Georgia\n\nShapefiles are not limited to just lines and areas—they can also contain points. I made a free account at the Georgia GIS Clearinghouse, searched for \"schools\" and found a shapefile of all the K–12 schools in 2009. [This is the direct link to the page](https://data.georgiaspatial.org/index.asp?body=preview&dataId=41516), but it only works if you're logged in to their system. [This is the official metadata for the shapefile](https://data.georgiaspatial.org/data/statewide/other/schools_2009.html), which you can see if you're not logged in, but you can't download anything. It's a dumb system and other states are a lot better at offering their GIS data (like, [here's a shapefile of all of Utah's schools and libraries](https://gis.utah.gov/data/society/schools-libraries/) as of 2017, publicly accessible without an account).\n\nWe loaded the shapefile up at the top, but now let's look at it:\n\n```{r}\nhead(ga_schools)\n```\n\nWe have a bunch of columns like `GRADES` that has a list of what grades are included in the school, and `TOTAL`, which I'm guessing is the number of students. Let's map it!\n\nIf we add a `geom_sf()` layer just for `ga_schools`, it'll plot a bunch of points:\n\n```{r plot-ga-schools-initial}\nggplot() +\n  geom_sf(data = ga_schools)\n```\n\nOne of these rows is wildly miscoded and ended up Indonesia! If you sort by the `geometry` column in RStudio, you'll see that it's most likely Allatoona High School in Cobb County (id = 22097). The coordinates are different from all the others, and it has no congressional district information. Let's remove it.\n\n```{r plot-ga-schools-fixed}\nga_schools_fixed <- ga_schools %>% \n  filter(ID != 22097)\n\nggplot() +\n  geom_sf(data = ga_schools_fixed)\n```\n\nThat's better. However, all we're plotting now are the points—we've lost the state and/or county boundaries. Let's include those:\n\n```{r plot-ga-schools-borders}\nggplot() +\n  geom_sf(data = only_georgia_high) +\n  geom_sf(data = ga_schools_fixed) +\n  theme_void()\n```\n\nWe're getting closer. We have some issues with overplotting, so let's shrink the points down and make them a little transparent:\n\n```{r plot-ga-schools-shrunk}\nggplot() +\n  geom_sf(data = only_georgia_high) +\n  geom_sf(data = ga_schools_fixed, size = 0.5, alpha = 0.5) +\n  theme_void()\n```\n\nNeat. One last thing we can do is map the `TOTAL` column to the color aesthetic and color the points by how many students attend each school:\n\n```{r plot-ga-schools-color}\nggplot() +\n  geom_sf(data = only_georgia_high) +\n  geom_sf(data = ga_schools_fixed, aes(color = TOTAL), size = 0.75, alpha = 0.5) +\n  scale_color_viridis_c() +\n  theme_void()\n```\n\nMost schools appear to be under 1,000 students, except for a cluster in Gwinnett County north of Atlanta. Its high schools have nearly 4,000 students each!\n\n```{r show-biggest-schools}\nga_schools_fixed %>% \n  select(COUNTY, SCHOOLNAME, TOTAL) %>% \n  arrange(desc(TOTAL)) %>% \n  head()\n```\n\n\n## Making your own geocoded data\n\nSo, plotting shapefiles with `geom_sf()` is magical because {sf} deals with all of the projection issues for us automatically and it figures out how to plot all the latitude and longitude data for us automatically. But lots of data *doesn't* some as shapefiles. The [rats data from mini project 1](/assignment/01-mini-project.qmd), for instance, has two columns indicating the latitude and longitude of each rat sighting, but those are stored as just numbers. If we try to use `geom_sf()` with the rat data, it won't work. We need that magical `geometry` column.\n\nFortunately, if we have latitude and longitude information, we can make our own `geometry` column. \n\nLet's say we want to mark some cities on our map of Georgia. We can make a mini dataset using `tribble()`. I found these points from Google Maps: right click anywhere in Google Maps, select \"What's here?\", and you'll see the exact coordinates for that spot.\n\n```{r mini-cities}\nga_cities <- tribble(\n  ~city, ~lat, ~long,\n  \"Atlanta\", 33.748955, -84.388099,\n  \"Athens\", 33.950794, -83.358884,\n  \"Savannah\", 32.113192, -81.089350\n)\nga_cities\n```\n\nThis is just a normal dataset, and the `lat` and `long` columns are just numbers. R doesn't know that those are actually geographic coordinates. This is similar to the rats data, or any other data that has columns for latitude and longitude.\n\nWe can convert those two columns to the magic `geometry` column with the `st_as_sf()` function. We have to define two things in the function: which coordinates are the longitude and latitude, and what CRS the coordinates are using. Google Maps uses [EPSG:4326, or the GPS system](http://epsg.io/4326), so we specify that:\n\n```{r mini-cities-convert}\nga_cities_geometry <- ga_cities %>% \n  st_as_sf(coords = c(\"long\", \"lat\"), crs = st_crs(\"EPSG:4326\"))\nga_cities_geometry\n```\n\nThe longitude and latitude columns are gone now, and we have a single magical `geometry` column. That means we can plot it with `geom_sf()`:\n\n```{r ga-with-cities}\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  geom_sf(data = ga_cities_geometry, size = 3) +\n  theme_void()\n```\n\nWe can use `geom_sf_label()` (or `geom_sf_text()`) to add labels in the correct locations too. It will give you a warning, but you can ignore it—again, it's complaining that the positioning might not be 100% accurate because of issues related to taking a globe and flattening it. It's fine.\n\n```{r ga-with-cities-text, warning=FALSE, fig.width=10, fig.height=6}\nggplot() +\n  geom_sf(data = only_georgia_high, fill = \"#EC8E55\") +\n  geom_sf(data = ga_cities_geometry, size = 3) +\n  geom_sf_label(data = ga_cities_geometry, aes(label = city),\n                nudge_y = 0.2) +\n  theme_void()\n```\n\n## Automatic geocoding by address\n\nUsing `st_as_sf()` is neat when you have latitude and longitude data already, but what if you have a list of addresses or cities instead, with no fancy geographic information? It's easy enough to right click on Google Maps, but you don't really want to do that hundreds of times for large-scale data.\n\nFortunately there are a bunch of different online geocoding services that return GIS data for addresses and locations that you feed them, like magic. \n\nThe easiest way to use any of these services is to use the [{tidygeocoder}](https://jessecambon.github.io/tidygeocoder/) package, which connects with all these different free and paid services (run `?geo` in R for complete details):\n\n- `\"osm\"`: OpenStreetMap through [Nominatim](https://nominatim.org/). **FREE**.\n- `\"census\"`: [US Census](https://geocoding.geo.census.gov/). Geographic coverage is limited to the United States. **FREE**.\n- `\"arcgis\"`: [ArcGIS](https://developers.arcgis.com/rest/geocode/api-reference/overview-world-geocoding-service.htm). **FREE** and paid.\n- `\"geocodio\"`: [Geocodio](https://www.geocod.io/). Geographic coverage is limited to the United States and Canada. An API key must be stored in `\"GEOCODIO_API_KEY\"`.\n- `\"iq\"`: [Location IQ](https://locationiq.com/). An API key must be stored in `\"LOCATIONIQ_API_KEY\"`.\n- `\"google\"`: [Google](https://developers.google.com/maps/documentation/geocoding/overview). An API key must be stored in `\"GOOGLEGEOCODE_API_KEY\"`.\n- `\"opencage\"`: [OpenCage](https://opencagedata.com/). An API key must be stored in `\"OPENCAGE_KEY\"`.\n- `\"mapbox\"`: [Mapbox](https://docs.mapbox.com/api/search/). An API key must be stored in `\"MAPBOX_API_KEY\"`.\n- `\"here\"`: [HERE](https://developer.here.com/products/geocoding-and-search). An API key must be stored in `\"HERE_API_KEY\"`.\n- `\"tomtom\"`: [TomTom](https://developer.tomtom.com/search-api/search-api-documentation/geocoding). An API key must be stored in `\"TOMTOM_API_KEY\"`.\n- `\"mapquest\"`: [MapQuest](https://developer.mapquest.com/documentation/geocoding-api/). An API key must be stored in `\"MAPQUEST_API_KEY\"`.\n- `\"bing\"`: [Bing](https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/). An API key must be stored in `\"BINGMAPS_API_KEY\"`.\n\nNot all services work equally well, and the free ones have rate limits (like, don't try to geocode a million rows of data with the US Census), so you'll have to play around with different services. You can also provide a list of services and {tidygeocoder} will cascade through them—if it can't geocode an address with OpenStreetMap, it can move on to the Census, then ArcGIS, and so on. You need to set the `cascade_order` argument in `geocode()` for this to work.\n\nLet's make a little dataset with some addresses to geocode: \n\n```{r build-some-addresses}\nsome_addresses <- tribble(\n  ~name,             ~address,\n  \"The White House\", \"1600 Pennsylvania Ave NW, Washington, DC\",\n  \"The Andrew Young School of Policy Studies\", \"55 Park Place SE, Atlanta, GA 30303\"\n)\n\nsome_addresses\n```\n\nTo geocode these addresses, we can feed this data into `geocode()` and tell it to use the `address` column. We'll use the Census geocoding system for fun (surely they know where the White House is):\n\n```{r geocode-fake, eval=FALSE}\nlibrary(tidygeocoder)\n\ngeocoded_addresses <- some_addresses %>% \n  geocode(address, method = \"census\")\n\ngeocoded_addresses\n```\n\n```{r show-geocode, echo=FALSE}\ngeocoded_addresses %>% \n  select(name, lat, long)\n```\n\nIt worked!\n\nThose are just numbers, though, and not the magical `geometry` column, so we need to use `st_as_sf()` to convert them to actual GIS data.\n\n```{r st-as-sf-geocoded}\naddresses_geometry <- geocoded_addresses %>% \n  st_as_sf(coords = c(\"long\", \"lat\"), crs = st_crs(\"EPSG:4326\"))\n\naddresses_geometry %>% select(-address)\n```\n\nLet's plot these on a US map:\n\n```{r plot-geocoded-cities}\nggplot() + \n  geom_sf(data = lower_48, fill = \"#192DA1\", color = \"white\", linewidth = 0.25) +\n  geom_sf(data = addresses_geometry, size = 5, color = \"#FF851B\") +\n  # Albers uses meters as its unit of measurement, so we need to nudge these\n  # labels up by a lot. I only settled on 175,000 here after a bunch of trial\n  # and error, adding single zeroes and rerunning the plot until the labels\n  # moved. 175,000 meters = 108.74 miles\n  geom_sf_label(data = addresses_geometry, aes(label = name),\n                size = 4, fill = \"#FF851B\", nudge_y = 175000) + \n  coord_sf(crs = st_crs(\"ESRI:102003\")) +  # Albers\n  theme_void()\n```\n\n## Plotting other data on maps\n\nSo far we've just plotted whatever data the shapefile creators decided to include and publish in their data. But what if you want to visualize some other variable on a map? We can do this by combining our shapefile data with any other kind of data, as long as the two have a shared column. For instance, we can make a choropleth map of life expectancy with data from the World Bank.\n\nFirst, let's grab some data from the World Bank for just 2015:\n\n```{r get-wdi, eval=FALSE}\nlibrary(WDI)  # For getting data from the World Bank\n\nindicators <- c(life_expectancy = \"SP.DYN.LE00.IN\")  # Life expectancy\n\nwdi_raw <- WDI(country = \"all\", indicators, extra = TRUE, \n               start = 2015, end = 2015)\n```\n\n```{r load-wdi, include=FALSE}\nwdi_raw <- read_csv(here::here(wdi_path))\n```\n\nLet's see what we got:\n\n```{r head-wdi-raw}\nhead(wdi_raw)\n```\n\nWe have a bunch of columns here, but we care about two in particular: life expectancy, and the ISO3 code. This three-letter code is a standard system for identifying countries ([see the full list here](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)), and that column will let us combine this World Bank data with the global shapefile, which also has a column for the ISO3 code.\n\n::: {.callout-note}\n### World capitals\n\nWe also have columns for the latitude and longitude for each capital, so we could theoretically convert those to a `geometry` column with `st_as_sf()` and plot world capitals, which would be neat, but we won't do that now.\n:::\n\nLet's clean up the WDI data by shrinking it down substantially so we only join the one `life_expectancy` column that we care about:\n\n```{r clean-wdi}\nwdi_clean_small <- wdi_raw %>% \n  select(life_expectancy, iso3c)\nwdi_clean_small\n```\n\nNext we need to merge this tiny dataset into the `world_map_sans_antarctica` shapefile data we were using earlier. To do this we'll use a function named `left_join()`. We feed two data frames into `left_join()`, and R will keep all the rows from the first and include all the columns from both the first and the second wherever the two datasets match with one specific column. That's wordy and weird—[stare at this animation here](https://github.com/gadenbuie/tidyexplain#left-join) for a few seconds to see what's really going to happen. We're essentially going to append the World Bank data to the end of the world shapefiles and line up rows that have matching ISO3 codes. The ISO3 column is named `ISO_A3` in the shapefile data, and it's named `iso3c` in the WDI data, so we tell `left_join()` that those are the same column:\n\n```{r combine-map-wdi}\nworld_map_with_life_expectancy <- world_sans_antarctica %>% \n  left_join(wdi_clean_small, by = c(\"ISO_A3\" = \"iso3c\"))\n```\n\nIf you look at this dataset in RStudio now and look at the last column, you'll see the WDI life expectancy right next to the magic `geometry` column.\n\nWe technically didn't need to shrink the WDI data down to just two columns—had we left everything else, all the WDI columns would have come over to the `world_sans_antarctica`, including columns for region and income level, etc. But I generally find it easier and cleaner to only merge in the columns I care about instead of making massive datasets with a billion extra columns.\n\nNow that we have a column for life expectancy, we can map it to the fill aesthetic and fill each country by 2015 life expectancy:\n\n```{r world-life-exp-2015, fig.width=10, fig.height=6}\nggplot() + \n  geom_sf(data = world_map_with_life_expectancy, \n          aes(fill = life_expectancy),\n          linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  scale_fill_viridis_c(option = \"viridis\") +\n  labs(fill = \"Life expectancy\") +\n  theme_void() +\n  theme(legend.position = \"bottom\")\n```\n\nVoila! Global life expectancy in 2015!\n\n---\n\n::: {.callout-tip}\n### France and Norway\n\nSharp-eyed readers will notice that France and Norway are grayed out because they're missing data. That's because the `ISO_A3` code in the Natural Earth data is missing for both France and Norway for whatever reason, so the WDI data didn't merge with those rows. To fix that, we can do some manual recoding before joining in the WDI data.\n:::\n\n```{r world-life-exp-2015-fixed, fig.width=10, fig.height=6}\nworld_sans_antarctica_fixed <- world_sans_antarctica %>% \n  mutate(ISO_A3 = case_when(\n    # If the country name is Norway or France, redo the ISO3 code\n    ADMIN == \"Norway\" ~ \"NOR\",\n    ADMIN == \"France\" ~ \"FRA\",\n    # Otherwise use the existing ISO3 code\n    TRUE ~ ISO_A3\n  )) %>% \n  left_join(wdi_clean_small, by = c(\"ISO_A3\" = \"iso3c\"))\n\nggplot() + \n  geom_sf(data = world_sans_antarctica_fixed, \n          aes(fill = life_expectancy),\n          linewidth = 0.25) +\n  coord_sf(crs = st_crs(\"ESRI:54030\")) +  # Robinson\n  scale_fill_viridis_c(option = \"viridis\") +\n  labs(fill = \"Life expectancy\") +\n  theme_void() +\n  theme(legend.position = \"bottom\")\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"monokai","toc-depth":4,"filters":["../filters/format_date_end.lua"],"output-file":"12-example.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["../files/bib/readings.bib"],"csl":"../files/bib/chicago-author-date.csl","_quarto-vars":{"author":"Andrew Heiss","instructor":{"name":"Dr. Andrew Heiss","name_no_title":"Andrew Heiss","email":"aheiss@gsu.edu","url":"https://www.andrewheiss.com","twitter":"andrewheiss","github":"andrewheiss","office":"55 Park Place SE, Room 464","contact_policy":"E-mail and Slack are the best ways to get in contact with me. I will try to respond to all course-related e-mails and Slack messages within 24 hours (*really*), but also remember that life can be busy and chaotic for everyone (including me!), so if I don't respond right away, don't worry!","appointment_url":"https://calendly.com/andrewheiss/"},"course":{"number":"PMAP 8551/4551","semester":"Fall 2023","days":"Any day","time":"Asynchronous","location":"Anywhere","dates":"August 12–December 11, 2023","github":"https://www.github.com/andrewheiss/datavizf23.classes.andrewheiss.com","url":"https://datavizf23.classes.andrewheiss.com","copyright_year":"2023","slack":"https://gsudatavizf2023.slack.com"},"university":{"name":"Georgia State University","url":"https://www.gsu.edu"},"school":{"name":"Andrew Young School of Policy Studies","url":"https://aysps.gsu.edu/"}},"theme":["litera","../html/custom.scss"],"date-heading":{"content":"Example for","class":"bg-example"},"date-format":"full","template-partials":["../html/title-block.html"],"title":"Space","date":"2023-11-06","date_end":"2023-11-10"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}