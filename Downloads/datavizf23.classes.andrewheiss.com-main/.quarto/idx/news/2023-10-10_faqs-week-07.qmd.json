{"title":"Week 7 tips and FAQs","markdown":{"yaml":{"title":"Week 7 tips and FAQs","date":"2023-10-10T12:04","categories":["FAQs"],"toc-depth":4},"headingText":"I tried to knit my document and got an error about duplicate chunk labels. Why?","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(\n  fig.width = 6, \n  fig.height = 6 * 0.618, \n  fig.align = \"center\", \n  out.width = \"90%\",\n  collapse = TRUE\n)\n```\n\nHi everyone!\n\nI just finished grading all your exercises from week 7 and am happy with how you've been doing! I have a few quick tips and tricks and suggestions here based on lots of the feedback I gave. Enjoy!\n\n\n\nYou can ([and should!](/resource/rmarkdown.qmd#chunk-names)) name your R code chunks—[see here for more about how and why](/resource/rmarkdown.qmd#chunk-names). All chunk names must be unique, though. \n\nOften you'll copy and paste a chunk from earlier in your document to later, like to make a second plot based on the first. That's fine—just make sure that you change the chunk name.\n\nIf there are chunks with repeated names, R will yell at you:\n\n![Duplicated chunk names](img/knitr-duplicate-chunks.png)\n\nTo fix it, change the name of one of the duplicated names to something unique:\n\n![Unique chunk names](img/knitr-different-names.png)\n\n\n### I tried calculating something with `sum()` or `cor()` and R gave me NA instead of a number. Why?\n\nThis nearly always happens because of missing values. Let's make a quick little dataset to illustrate what's going on (and how to fix it):\n\n```{r make-example-na-data, warning=FALSE, message=FALSE}\nlibrary(tidyverse)\n\nexample <- tibble(\n  x = c(1, 2, 3, 4, 5),\n  y = c(6, 7, NA, 9, 10),\n  z = c(2, 6, 5, 7, 3)\n)\n\nexample\n```\n\nThe `y` column has a missing value (`NA`), which will mess up any math we do.\n\nWithout running any code, what's the average of the `x` column? We can find that with math (add all the numbers up and divide by how many numbers there are):\n\n$$\n\\frac{1 + 2 + 3 + 4 + 5}{5} = 3\n$$\n\nNeat. We can confirm with R:\n\n```{r avg-good}\n# With dplyr\nexample %>% \n  summarize(avg = mean(x))\n\n# With base R\nmean(example$x)\n```\n\nWhat's the average of the `y` column? Math time:\n\n$$\n\\frac{6 + 7 + \\text{?} + 9 + 10}{5} = \\text{Who even knows}\n$$\n\nWe have no way of knowing what the average is because of that missing value.\n\nIf we try it with R, it gives us NA instead of a number:\n\n```{r avg-na}\nexample %>% \n  summarize(avg = mean(y))\n```\n\nTo fix this, we can tell R to remove all the missing values from the column before calculating the average so that it does this:\n\n$$\n\\frac{6 + 7 + 9 + 10}{4} = 8\n$$\n\nInclude the argument `na.rm = TRUE` to do that:\n\n```{r avg-na-rm}\nexample %>% \n  summarize(avg = mean(y, na.rm = TRUE))\n```\n\nThis works for lots of R's calculating functions, like `sum()`, `min()`, `max()`, `sd()`, `median()`, `mean()`, and so on:\n\n```{r summarize-lots}\nexample %>% \n  summarize(\n    total = sum(y, na.rm = TRUE),\n    avg = mean(y, na.rm = TRUE),\n    median = median(y, na.rm = TRUE),\n    min = min(y, na.rm = TRUE),\n    max = max(y, na.rm = TRUE),\n    std_dev = sd(y, na.rm = TRUE)\n  )\n```\n\nThis works a little differently with `cor()` because you're working with multiple columns instead of just one. If there are any missing values in any of the columns you're correlating, you'll get NA for the columns that use it. Here, we have a correlation between `x` and `z` because there are no missing values in either of those, but we get NA for the correlation between `x` and `y` and between `z` and `y`:\n\n```{r cor-missing}\nexample %>% \n  cor()\n```\n\nAdding `na.rm` to `cor()` doesn't work because `cor()` doesn't actually have an argument for `na.rm`:\n\n```{r cor-na-rm, error=TRUE}\nexample %>%\n  cor(na.rm = TRUE)\n```\n\nInstead, if you look at the documentation for `cor()` (run `?cor` in your R console or search for it in the Help panel in RStudio), you'll see an argument named `use` instead. By default it will use all the rows in the data (`use = \"everything\"`), but we can change it to `use = \"complete.obs\"`. This will remove all rows where something is missing before calculating the correlation:\n\n```{r cor-complete, error=TRUE}\nexample %>%\n  cor(use = \"complete.obs\")\n```\n\n\n### I want my bars to be sorted in my plot. How can I control their order?\n\nSorting categories by different values is important for showing trends in your data. By default, R will plot categorical variables in alphabetical order, but often you'll want these categories to use some sort of numeric order, likely based on a different column. \n\nThere are a few different ways to sort categories. First, let's make a summarized dataset of the total population in each continent in 2007 (using our trusty ol' gapminder data):\n\n```{r make-gapminder-data}\nlibrary(gapminder)\n\n# Find the total population in each continent in 2007\npopulation_by_continent <- gapminder %>% \n  filter(year == 2007) %>% \n  group_by(continent) %>% \n  summarize(total_population = sum(pop))\npopulation_by_continent\n```\n\nBy default the continents will be in alphabetic order:\n\n```{r plot-gapminder-alphabetic}\nggplot(\n  population_by_continent,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")  # The legend is redundant because of the x-axis\n```\n\nIn this case it's more useful to plot these in order of total population. My favorite approach for this is to (1) sort the data how I want it with `arrange()` and (2) lock the order of the category in place with `fct_inorder()`. Note how the mini dataset is now sorted and Oceania comes first:\n\n```{r make-gapminder-sorted}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population\n  arrange(total_population) %>% \n  # Make continent use the order it's currently in\n  mutate(continent = fct_inorder(continent))\nplot_data_sorted\n```\n\nIf we plot it, the continents will be in order:\n\n```{r plot-gapminder-sorted}\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\nThis plots the continents in reverse order, with Oceania on the left. We can reverse this by either arranging the data in descending population order, or by using `fct_rev()` to reverse the continent order:\n\n::: {.panel-tabset}\n### Sort in descending order\n\n```{r plot-gapminder-desc}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population in descending order\n  arrange(desc(total_population)) %>% \n  # Lock in the continent order\n  mutate(continent = fct_inorder(continent))\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n### Use `fct_rev()`\n\n```{r plot-gapminder-fct-rev}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population in ascending order\n  arrange(total_population) %>% \n  # Lock in the continent order\n  mutate(continent = fct_inorder(continent))\n\nggplot(\n  plot_data_sorted,\n  # Reverse the continent order with fct_rev()\n  aes(x = fct_rev(continent), y = total_population, fill = fct_rev(continent))\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n:::\n\nAn alternative to the two-step `arrange() %>% mutate(blah = fct_inorder(blah))` is to use `fct_reorder()`, which takes two arguments: (1) the column you want to be reordered and (2) the column you want to sort it by:\n\n```{r plot-gapminder-fct-reorder}\nplot_data_sorted <- population_by_continent %>% \n  # Sort continent by total_population in descending order\n  mutate(continent = fct_reorder(continent, total_population, .desc = TRUE))\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\nThat's only one line instead of two, which is nice, but I tend to be fan of the two step approach because it's more explicit and gives me more control over sorting. For instance, here I want all the gapminder countries to be sorted by year (descending), continent, and life expectancy so we can see descending life expectancy within each continent over time. \n\nI'm sure there's a way to sort by multiple columns in different orders like this with `fct_reorder()`, but I don't know how. Plus, if I run this `super_sorted_data` code up until the end of `arrange()`, I can look at it in RStudio to make sure all the ordering I want is right. That's harder to do with `fct_reorder()`.\n\n```{r gapminder-wild, fig.width=8, fig.height=7}\nsuper_sorted_data <- gapminder %>% \n  filter(year >= 1997) %>% \n  # Get the countries in order of year (descending), continent, and life expectancy\n  arrange(desc(year), continent, lifeExp) %>%\n  # Lock the country name order in place + lock the year in place\n  mutate(\n    country = fct_inorder(country),\n    # year is currently a number, so we need to change it to a factor before\n    # reordering it\n    year = fct_inorder(factor(year))\n  )\n\nggplot(super_sorted_data, aes(y = country, x = lifeExp, fill = continent)) +\n  geom_col() +\n  facet_wrap(vars(year)) +\n  # Reverse the order legend so that Oceania is at the top, since it's at the\n  # top in the plot\n  guides(fill = guide_legend(reverse = TRUE)) +\n  theme_minimal() +\n  # Remove country names and y-axis gridlines + put legend on the bottom\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"bottom\"\n  )\n```\n\nYou can also specify any arbitrary category order with `fct_relevel()`\n\n```{r plot-gapminder-arbitrary}\nplot_data_sorted <- population_by_continent %>% \n  # Use this specific continent order\n  mutate(continent = fct_relevel(\n    continent, \n    c(\"Asia\", \"Oceania\", \"Europe\", \"Americas\", \"Africa\"))\n  )\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n\n### My data has full US state names but I want to use abbreviations (or regions). Is there a way to automatically convert from names to something else?\n\nYep! R has a few state-related variables built in (run `?state` in your R console to see them all):\n\n```{r state-examples}\nstate.name\nstate.abb\nstate.region\n```\n\nThese aren't datasets—they're single vectors—but you can make a little dataset with columns for each of those details, like this:\n\n```{r make-state-details}\nstate_details <- tibble(\n  state = state.name,\n  state_abb = state.abb,\n  state_division = state.division,\n  state_region = state.region\n) %>% \n  # Add DC manually\n  add_row(\n    state = \"Washington, DC\",\n    state_abb = \"DC\",\n    state_division = \"South Atlantic\",\n    state_region = \"South\"\n  )\nstate_details\n```\n\nYou can join this dataset to any data you have that has state names or state abbreviations. Joining the data will bring all the columns from `state_details` into your data wherever rows match. You'll [learn a lot more about joining things in sesison 12 too](/lesson/12-lesson.qmd).\n\nFor instance, imagine you have a dataset that looks like this, similar to the unemployment data from exercise 8:\n\n```{r make-state-data}\nsome_state_data <- tribble(\n  ~state, ~something,\n  \"Wyoming\", 5,\n  \"North Carolina\", 9,\n  \"Nevada\", 10,\n  \"Georgia\", 3,\n  \"Rhode Island\", 1,\n  \"Washington, DC\", 6\n)\nsome_state_data\n```\n\nWe can merge in (or join) the `state_details` data so that we add columns for abbreviation, region, and so on, using `left_join()` (again, [see lesson 12 for more about all this](/lesson/12-lesson.qmd)):\n\n```{r join-state-details}\n# Join the state details\ndata_with_state_details <- some_state_data %>% \n  left_join(state_details, by = join_by(state))\ndata_with_state_details\n```\n\nNow your `data_with_state_details` data has new columns for abbreviations, divisions, regions, and everything else that was in `state_details`:\n\n```{r plot-state-abbreviations}\n# Use it\nggplot(\n  data_with_state_details, \n  aes(x = state_abb, y = something, fill = state_region)\n) +\n  geom_col()\n```\n\nAnd for fun, we can fix the ordering:\n\n```{r plot-state-abbreviations-ordering}\n# Fix the ordering\ndata_with_state_details <- some_state_data %>% \n  left_join(state_details, by = join_by(state)) %>% \n  arrange(desc(something)) %>% \n  mutate(state_abb = fct_inorder(state_abb))\n\nggplot(\n  data_with_state_details, \n  aes(x = state_abb, y = something, fill = state_region)\n) +\n  geom_col()\n```\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(\n  fig.width = 6, \n  fig.height = 6 * 0.618, \n  fig.align = \"center\", \n  out.width = \"90%\",\n  collapse = TRUE\n)\n```\n\nHi everyone!\n\nI just finished grading all your exercises from week 7 and am happy with how you've been doing! I have a few quick tips and tricks and suggestions here based on lots of the feedback I gave. Enjoy!\n\n\n### I tried to knit my document and got an error about duplicate chunk labels. Why?\n\nYou can ([and should!](/resource/rmarkdown.qmd#chunk-names)) name your R code chunks—[see here for more about how and why](/resource/rmarkdown.qmd#chunk-names). All chunk names must be unique, though. \n\nOften you'll copy and paste a chunk from earlier in your document to later, like to make a second plot based on the first. That's fine—just make sure that you change the chunk name.\n\nIf there are chunks with repeated names, R will yell at you:\n\n![Duplicated chunk names](img/knitr-duplicate-chunks.png)\n\nTo fix it, change the name of one of the duplicated names to something unique:\n\n![Unique chunk names](img/knitr-different-names.png)\n\n\n### I tried calculating something with `sum()` or `cor()` and R gave me NA instead of a number. Why?\n\nThis nearly always happens because of missing values. Let's make a quick little dataset to illustrate what's going on (and how to fix it):\n\n```{r make-example-na-data, warning=FALSE, message=FALSE}\nlibrary(tidyverse)\n\nexample <- tibble(\n  x = c(1, 2, 3, 4, 5),\n  y = c(6, 7, NA, 9, 10),\n  z = c(2, 6, 5, 7, 3)\n)\n\nexample\n```\n\nThe `y` column has a missing value (`NA`), which will mess up any math we do.\n\nWithout running any code, what's the average of the `x` column? We can find that with math (add all the numbers up and divide by how many numbers there are):\n\n$$\n\\frac{1 + 2 + 3 + 4 + 5}{5} = 3\n$$\n\nNeat. We can confirm with R:\n\n```{r avg-good}\n# With dplyr\nexample %>% \n  summarize(avg = mean(x))\n\n# With base R\nmean(example$x)\n```\n\nWhat's the average of the `y` column? Math time:\n\n$$\n\\frac{6 + 7 + \\text{?} + 9 + 10}{5} = \\text{Who even knows}\n$$\n\nWe have no way of knowing what the average is because of that missing value.\n\nIf we try it with R, it gives us NA instead of a number:\n\n```{r avg-na}\nexample %>% \n  summarize(avg = mean(y))\n```\n\nTo fix this, we can tell R to remove all the missing values from the column before calculating the average so that it does this:\n\n$$\n\\frac{6 + 7 + 9 + 10}{4} = 8\n$$\n\nInclude the argument `na.rm = TRUE` to do that:\n\n```{r avg-na-rm}\nexample %>% \n  summarize(avg = mean(y, na.rm = TRUE))\n```\n\nThis works for lots of R's calculating functions, like `sum()`, `min()`, `max()`, `sd()`, `median()`, `mean()`, and so on:\n\n```{r summarize-lots}\nexample %>% \n  summarize(\n    total = sum(y, na.rm = TRUE),\n    avg = mean(y, na.rm = TRUE),\n    median = median(y, na.rm = TRUE),\n    min = min(y, na.rm = TRUE),\n    max = max(y, na.rm = TRUE),\n    std_dev = sd(y, na.rm = TRUE)\n  )\n```\n\nThis works a little differently with `cor()` because you're working with multiple columns instead of just one. If there are any missing values in any of the columns you're correlating, you'll get NA for the columns that use it. Here, we have a correlation between `x` and `z` because there are no missing values in either of those, but we get NA for the correlation between `x` and `y` and between `z` and `y`:\n\n```{r cor-missing}\nexample %>% \n  cor()\n```\n\nAdding `na.rm` to `cor()` doesn't work because `cor()` doesn't actually have an argument for `na.rm`:\n\n```{r cor-na-rm, error=TRUE}\nexample %>%\n  cor(na.rm = TRUE)\n```\n\nInstead, if you look at the documentation for `cor()` (run `?cor` in your R console or search for it in the Help panel in RStudio), you'll see an argument named `use` instead. By default it will use all the rows in the data (`use = \"everything\"`), but we can change it to `use = \"complete.obs\"`. This will remove all rows where something is missing before calculating the correlation:\n\n```{r cor-complete, error=TRUE}\nexample %>%\n  cor(use = \"complete.obs\")\n```\n\n\n### I want my bars to be sorted in my plot. How can I control their order?\n\nSorting categories by different values is important for showing trends in your data. By default, R will plot categorical variables in alphabetical order, but often you'll want these categories to use some sort of numeric order, likely based on a different column. \n\nThere are a few different ways to sort categories. First, let's make a summarized dataset of the total population in each continent in 2007 (using our trusty ol' gapminder data):\n\n```{r make-gapminder-data}\nlibrary(gapminder)\n\n# Find the total population in each continent in 2007\npopulation_by_continent <- gapminder %>% \n  filter(year == 2007) %>% \n  group_by(continent) %>% \n  summarize(total_population = sum(pop))\npopulation_by_continent\n```\n\nBy default the continents will be in alphabetic order:\n\n```{r plot-gapminder-alphabetic}\nggplot(\n  population_by_continent,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")  # The legend is redundant because of the x-axis\n```\n\nIn this case it's more useful to plot these in order of total population. My favorite approach for this is to (1) sort the data how I want it with `arrange()` and (2) lock the order of the category in place with `fct_inorder()`. Note how the mini dataset is now sorted and Oceania comes first:\n\n```{r make-gapminder-sorted}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population\n  arrange(total_population) %>% \n  # Make continent use the order it's currently in\n  mutate(continent = fct_inorder(continent))\nplot_data_sorted\n```\n\nIf we plot it, the continents will be in order:\n\n```{r plot-gapminder-sorted}\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\nThis plots the continents in reverse order, with Oceania on the left. We can reverse this by either arranging the data in descending population order, or by using `fct_rev()` to reverse the continent order:\n\n::: {.panel-tabset}\n### Sort in descending order\n\n```{r plot-gapminder-desc}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population in descending order\n  arrange(desc(total_population)) %>% \n  # Lock in the continent order\n  mutate(continent = fct_inorder(continent))\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n### Use `fct_rev()`\n\n```{r plot-gapminder-fct-rev}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population in ascending order\n  arrange(total_population) %>% \n  # Lock in the continent order\n  mutate(continent = fct_inorder(continent))\n\nggplot(\n  plot_data_sorted,\n  # Reverse the continent order with fct_rev()\n  aes(x = fct_rev(continent), y = total_population, fill = fct_rev(continent))\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n:::\n\nAn alternative to the two-step `arrange() %>% mutate(blah = fct_inorder(blah))` is to use `fct_reorder()`, which takes two arguments: (1) the column you want to be reordered and (2) the column you want to sort it by:\n\n```{r plot-gapminder-fct-reorder}\nplot_data_sorted <- population_by_continent %>% \n  # Sort continent by total_population in descending order\n  mutate(continent = fct_reorder(continent, total_population, .desc = TRUE))\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\nThat's only one line instead of two, which is nice, but I tend to be fan of the two step approach because it's more explicit and gives me more control over sorting. For instance, here I want all the gapminder countries to be sorted by year (descending), continent, and life expectancy so we can see descending life expectancy within each continent over time. \n\nI'm sure there's a way to sort by multiple columns in different orders like this with `fct_reorder()`, but I don't know how. Plus, if I run this `super_sorted_data` code up until the end of `arrange()`, I can look at it in RStudio to make sure all the ordering I want is right. That's harder to do with `fct_reorder()`.\n\n```{r gapminder-wild, fig.width=8, fig.height=7}\nsuper_sorted_data <- gapminder %>% \n  filter(year >= 1997) %>% \n  # Get the countries in order of year (descending), continent, and life expectancy\n  arrange(desc(year), continent, lifeExp) %>%\n  # Lock the country name order in place + lock the year in place\n  mutate(\n    country = fct_inorder(country),\n    # year is currently a number, so we need to change it to a factor before\n    # reordering it\n    year = fct_inorder(factor(year))\n  )\n\nggplot(super_sorted_data, aes(y = country, x = lifeExp, fill = continent)) +\n  geom_col() +\n  facet_wrap(vars(year)) +\n  # Reverse the order legend so that Oceania is at the top, since it's at the\n  # top in the plot\n  guides(fill = guide_legend(reverse = TRUE)) +\n  theme_minimal() +\n  # Remove country names and y-axis gridlines + put legend on the bottom\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"bottom\"\n  )\n```\n\nYou can also specify any arbitrary category order with `fct_relevel()`\n\n```{r plot-gapminder-arbitrary}\nplot_data_sorted <- population_by_continent %>% \n  # Use this specific continent order\n  mutate(continent = fct_relevel(\n    continent, \n    c(\"Asia\", \"Oceania\", \"Europe\", \"Americas\", \"Africa\"))\n  )\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n\n### My data has full US state names but I want to use abbreviations (or regions). Is there a way to automatically convert from names to something else?\n\nYep! R has a few state-related variables built in (run `?state` in your R console to see them all):\n\n```{r state-examples}\nstate.name\nstate.abb\nstate.region\n```\n\nThese aren't datasets—they're single vectors—but you can make a little dataset with columns for each of those details, like this:\n\n```{r make-state-details}\nstate_details <- tibble(\n  state = state.name,\n  state_abb = state.abb,\n  state_division = state.division,\n  state_region = state.region\n) %>% \n  # Add DC manually\n  add_row(\n    state = \"Washington, DC\",\n    state_abb = \"DC\",\n    state_division = \"South Atlantic\",\n    state_region = \"South\"\n  )\nstate_details\n```\n\nYou can join this dataset to any data you have that has state names or state abbreviations. Joining the data will bring all the columns from `state_details` into your data wherever rows match. You'll [learn a lot more about joining things in sesison 12 too](/lesson/12-lesson.qmd).\n\nFor instance, imagine you have a dataset that looks like this, similar to the unemployment data from exercise 8:\n\n```{r make-state-data}\nsome_state_data <- tribble(\n  ~state, ~something,\n  \"Wyoming\", 5,\n  \"North Carolina\", 9,\n  \"Nevada\", 10,\n  \"Georgia\", 3,\n  \"Rhode Island\", 1,\n  \"Washington, DC\", 6\n)\nsome_state_data\n```\n\nWe can merge in (or join) the `state_details` data so that we add columns for abbreviation, region, and so on, using `left_join()` (again, [see lesson 12 for more about all this](/lesson/12-lesson.qmd)):\n\n```{r join-state-details}\n# Join the state details\ndata_with_state_details <- some_state_data %>% \n  left_join(state_details, by = join_by(state))\ndata_with_state_details\n```\n\nNow your `data_with_state_details` data has new columns for abbreviations, divisions, regions, and everything else that was in `state_details`:\n\n```{r plot-state-abbreviations}\n# Use it\nggplot(\n  data_with_state_details, \n  aes(x = state_abb, y = something, fill = state_region)\n) +\n  geom_col()\n```\n\nAnd for fun, we can fix the ordering:\n\n```{r plot-state-abbreviations-ordering}\n# Fix the ordering\ndata_with_state_details <- some_state_data %>% \n  left_join(state_details, by = join_by(state)) %>% \n  arrange(desc(something)) %>% \n  mutate(state_abb = fct_inorder(state_abb))\n\nggplot(\n  data_with_state_details, \n  aes(x = state_abb, y = something, fill = state_region)\n) +\n  geom_col()\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"monokai","toc-depth":4,"output-file":"2023-10-10_faqs-week-07.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Posted","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["../files/bib/readings.bib"],"csl":"../files/bib/chicago-author-date.csl","_quarto-vars":{"author":"Andrew Heiss","instructor":{"name":"Dr. Andrew Heiss","name_no_title":"Andrew Heiss","email":"aheiss@gsu.edu","url":"https://www.andrewheiss.com","twitter":"andrewheiss","github":"andrewheiss","office":"55 Park Place SE, Room 464","contact_policy":"E-mail and Slack are the best ways to get in contact with me. I will try to respond to all course-related e-mails and Slack messages within 24 hours (*really*), but also remember that life can be busy and chaotic for everyone (including me!), so if I don't respond right away, don't worry!","appointment_url":"https://calendly.com/andrewheiss/"},"course":{"number":"PMAP 8551/4551","semester":"Fall 2023","days":"Any day","time":"Asynchronous","location":"Anywhere","dates":"August 12–December 11, 2023","github":"https://www.github.com/andrewheiss/datavizf23.classes.andrewheiss.com","url":"https://datavizf23.classes.andrewheiss.com","copyright_year":"2023","slack":"https://gsudatavizf2023.slack.com"},"university":{"name":"Georgia State University","url":"https://www.gsu.edu"},"school":{"name":"Andrew Young School of Policy Studies","url":"https://aysps.gsu.edu/"}},"theme":["litera","../html/custom.scss"],"date-format":"dddd MMMM D, YYYY [at] h:mm A","template-partials":["../html/news/title-block.html"],"title":"Week 7 tips and FAQs","date":"2023-10-10T12:04","categories":["FAQs"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}