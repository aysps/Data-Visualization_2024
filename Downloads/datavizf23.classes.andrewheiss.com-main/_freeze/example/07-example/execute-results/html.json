{
  "hash": "acc95e89b6f1ab123d471e94e7930a0a",
  "result": {
    "markdown": "---\ntitle: \"Relationships\"\ndate: \"2023-10-02\"\ndate_end: \"2023-10-06\"\n---\n\n\nFor this example, we're going to use historical weather data from the now-defunct [Dark Sky](https://darksky.net/forecast/33.7546,-84.39/us12/en) about wind speed and temperature trends for downtown Atlanta ([specifically `33.754557, -84.390009`](https://www.google.com/maps/place/33°45'16.4\"N+84°23'24.0\"W/@33.754557,-84.3921977,17z/)) in 2019. I downloaded this data using Dark Sky's (now-retired-because-they-were-bought-by-Apple) API using the [ {darksky} package](https://github.com/hrbrmstr/darksky).\nIf you want to follow along with this example, you can download the data below (you'll likely need to right click and choose \"Save Link As…\"):\n\n- [{{< fa file-csv >}} `atl-weather-2019.csv`](/files/data/external_data/atl-weather-2019.csv)\n\n\n## Live coding example\n\n<div class=\"ratio ratio-16x9\">\n<iframe src=\"https://www.youtube.com/embed/zfEAmJzfbkE\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\"></iframe>\n</div>\n\n\n::: {.callout-important}\n### Slight differences from the video\n\nThis is a slightly cleaned up version of the code from the video.\n:::\n\n\n\n\n\n## Load and clean data\n\nFirst, we load the libraries we'll be using:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # For ggplot, dplyr, and friends\nlibrary(patchwork)  # For combining ggplot plots\nlibrary(GGally)     # For scatterplot matrices\nlibrary(broom)      # For converting model objects to data frames\n```\n:::\n\n\nThen we load the data with `read_csv()`. Here I assume that the CSV file lives in a subfolder in my project named `data`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nweather_atl <- read_csv(\"data/atl-weather-2019.csv\")\n```\n:::\n\n\n\n\n## Legal dual y-axes\n\nIt is fine (and often helpful!) to use two y-axes if the two different scales measure the same thing, like counts and percentages, Fahrenheit and Celsius, pounds and kilograms, inches and centimeters, etc.\n\nTo do this, you need to add an argument (`sec.axis`) to `scale_y_continuous()` to tell it to use a second axis. This `sec.axis` argument takes a `sec_axis()` function that tells ggplot how to transform the scale. You need to specify a formula or function that defines how the original axis gets transformed. This formula uses a special syntax. It needs to start with a `~`, which indicates that it's a function, and it needs to use `.` to stand in for the original value in the original axis. \n\nSince the equation for converting Fahrenheit to Celsius is this…\n\n$$\n\\text{C} = (32 - \\text{F}) \\times -\\frac{5}{9}\n$$\n\n…we can specify this with code like so (where `.` stands for the Fahrenheit value):\n\n```default\n~ (32 - .) * -5 / 9\n```\n\nHere's a plot of daily high temperatures in Atlanta throughout 2019, with a second axis:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(weather_atl, aes(x = time, y = temperatureHigh)) +\n  geom_line() +\n  scale_y_continuous(sec.axis = sec_axis(trans = ~ (32 - .) * -5/9,\n                                         name = \"Celsius\")) +\n  labs(x = NULL, y = \"Fahrenheit\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/atl-weather-dual-axes-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nFor fun, we could also convert it to Kelvin, which uses this formula:\n\n$$\n\\text{K} = (\\text{F} - 32) \\times \\frac{5}{9} + 273.15\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(weather_atl, aes(x = time, y = temperatureHigh)) +\n  geom_line() +\n  scale_y_continuous(sec.axis = sec_axis(trans = ~ (. - 32) * 5/9 + 273.15,\n                                         name = \"Kelvin\")) +\n  labs(x = NULL, y = \"Fahrenheit\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/atl-weather-dual-axes-kelvin-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n## Combining plots\n\nA good alternative to using two y-axes is to use two plots instead. The [{patchwork} package](https://github.com/thomasp85/patchwork) makes this *really* easy to do with R. There are other similar packages that do this, like {cowplot} and {gridExtra}, but I've found that {patchwork} is the easiest to use *and* it actually aligns the different plot elements like axis lines and legends (yay alignment in CRAP!). The [documentation for {patchwork}](https://patchwork.data-imaginist.com/articles/guides/assembly.html) is really great and full of examples—you should check it out to see all the things you can do with it!\n\nTo use {patchwork}, we need to (1) save our plots as objects and (2) add them together with `+`.\n\nFor instance, is there a relationship between temperature and humidity in Atlanta? We can plot both:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Temperature in Atlanta\ntemp_plot <- ggplot(weather_atl, aes(x = time, y = temperatureHigh)) +\n  geom_line() +\n  geom_smooth() +\n  scale_y_continuous(sec.axis = sec_axis(trans = ~ (32 - .) * -5/9,\n                                         name = \"Celsius\")) +\n  labs(x = NULL, y = \"Fahrenheit\") +\n  theme_minimal()\ntemp_plot\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/create-temp-humid-plots-1.png){fig-align='center' width=576}\n:::\n\n```{.r .cell-code}\n\n# Humidity in Atlanta\nhumidity_plot <- ggplot(weather_atl, aes(x = time, y = humidity)) +\n  geom_line() +\n  geom_smooth() +\n  labs(x = NULL, y = \"Humidity\") +\n  theme_minimal()\nhumidity_plot\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/create-temp-humid-plots-2.png){fig-align='center' width=576}\n:::\n:::\n\n\nRight now, these are two separate plots, but we can combine them with `+` if we load {patchwork}:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\ntemp_plot + humidity_plot\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/patchwork-first-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nBy default, {patchwork} will put these side-by-side, but we can change that with the `plot_layout()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntemp_plot + humidity_plot +\n  plot_layout(ncol = 1)\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/patchwork-vertical-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nWe can also play with other arguments in `plot_layout()`. If we want to make the temperature plot taller and shrink the humidity section, we can specify the proportions for the plot heights. Here, the temperature plot is 70% of the height and the humidity plot is 30%:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntemp_plot + humidity_plot +\n  plot_layout(ncol = 1, heights = c(0.7, 0.3))\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/patchwork-vertical-resized-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n## Scatterplot matrices\n\nWe can visualize the correlations between pairs of variables with the `ggpairs()` function in the {GGally} package. For instance, how correlated are high and low temperatures, humidity, wind speed, and the chance of precipitation? We first make a smaller dataset with just those columns, and then we feed that dataset into `ggpairs()` to see all the correlation information:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(GGally)\n\nweather_correlations <- weather_atl %>% \n  select(temperatureHigh, temperatureLow, humidity, windSpeed, precipProbability)\n\nggpairs(weather_correlations)\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/ggpairs-1.png){fig-align='center' width=864}\n:::\n:::\n\n\nIt looks like high and low temperatures are extremely highly positively correlated (r = 0.92). Wind spped and temperature are moderately negatively correlated, with low temperatures having a stronger negative correlation (r = -0.45). There's no correlation whatsoever between low temperatures and the precipitation probability (r = -0.03) or humidity and high temperatures (r = -0.03).\n\nEven though `ggpairs()` doesn't use the standard `ggplot(...) + geom_whatever()` syntax we're familiar with, it does behind the scenes, so you can add regular ggplot layers to it:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggpairs(weather_correlations) +\n  labs(title = \"Correlations!\") +\n  theme_dark()\n```\n:::\n\n\n\n## Correlograms\n\nScatterplot matrices typically include way too much information to be used in actual publications. I use them when doing my own analysis just to see how different variables are related, but I rarely polish them up for public consumption. In the readings for this week, Claus Wilke showed a type of plot called a [*correlogram*](https://clauswilke.com/dataviz/visualizing-associations.html#associations-correlograms) which *is* more appropriate for publication. \n\nThese are essentially heatmaps of the different correlation coefficients. To make these with ggplot, we need to do a little bit of extra data processing, mostly to reshape data into a long, tidy format that we can plot. Here's how.\n\nFirst we need to build a correlation matrix of the main variables we care about. Ordinarily the `cor()` function in R takes two arguments—x and y—and it will return a single correlation value. If you feed a data frame into `cor()` though, it'll calculate the correlation between each pair of columns\n\n\n::: {.cell layout-align=\"center\" width='150'}\n\n```{.r .cell-code}\n# Create a correlation matrix\nthings_to_correlate <- weather_atl %>% \n  select(temperatureHigh, temperatureLow, humidity, windSpeed, precipProbability) %>% \n  cor()\n\nthings_to_correlate\n##                   temperatureHigh temperatureLow humidity windSpeed precipProbability\n## temperatureHigh              1.00          0.920   -0.030    -0.377            -0.124\n## temperatureLow               0.92          1.000    0.112    -0.450            -0.026\n## humidity                    -0.03          0.112    1.000     0.011             0.722\n## windSpeed                   -0.38         -0.450    0.011     1.000             0.196\n## precipProbability           -0.12         -0.026    0.722     0.196             1.000\n```\n:::\n\n\nThe two halves of this matrix (split along the diagonal line) are identical, so we can remove the lower triangle with this code (which will set all the cells in the lower triangle to `NA`):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get rid of the lower triangle\nthings_to_correlate[lower.tri(things_to_correlate)] <- NA\nthings_to_correlate\n##                   temperatureHigh temperatureLow humidity windSpeed precipProbability\n## temperatureHigh                 1           0.92    -0.03    -0.377            -0.124\n## temperatureLow                 NA           1.00     0.11    -0.450            -0.026\n## humidity                       NA             NA     1.00     0.011             0.722\n## windSpeed                      NA             NA       NA     1.000             0.196\n## precipProbability              NA             NA       NA        NA             1.000\n```\n:::\n\n\nFinally, in order to plot this, the data needs to be in tidy (or long) format. Here we convert the `things_to_correlate` matrix into a data frame, add a column for the row names, take all the columns and put them into a single column named `measure1`, and take all the correlation numbers and put them in a column named `cor` In the end, we make sure the measure variables are ordered by their order of appearance (otherwise they plot alphabetically and don't make a triangle)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nthings_to_correlate_long <- things_to_correlate %>% \n  # Convert from a matrix to a data frame\n  as.data.frame() %>% \n  # Matrixes have column names that don't get converted to columns when using\n  # as.data.frame(), so this adds those names as a column\n  rownames_to_column(\"measure2\") %>% \n  # Make this long. Take all the columns except measure2 and put their names in\n  # a column named measure1 and their values in a column named cor\n  pivot_longer(cols = -measure2,\n               names_to = \"measure1\",\n               values_to = \"cor\") %>% \n  # Make a new column with the rounded version of the correlation value\n  mutate(nice_cor = round(cor, 2)) %>% \n  # Remove rows where the two measures are the same (like the correlation\n  # between humidity and humidity)\n  filter(measure2 != measure1) %>%\n  # Get rid of the empty triangle\n  filter(!is.na(cor)) %>% \n  # Put these categories in order\n  mutate(measure1 = fct_inorder(measure1),\n         measure2 = fct_inorder(measure2))\n\nthings_to_correlate_long\n## # A tibble: 10 × 4\n##    measure2        measure1              cor nice_cor\n##    <fct>           <fct>               <dbl>    <dbl>\n##  1 temperatureHigh temperatureLow     0.920      0.92\n##  2 temperatureHigh humidity          -0.0301    -0.03\n##  3 temperatureHigh windSpeed         -0.377     -0.38\n##  4 temperatureHigh precipProbability -0.124     -0.12\n##  5 temperatureLow  humidity           0.112      0.11\n##  6 temperatureLow  windSpeed         -0.450     -0.45\n##  7 temperatureLow  precipProbability -0.0255    -0.03\n##  8 humidity        windSpeed          0.0108     0.01\n##  9 humidity        precipProbability  0.722      0.72\n## 10 windSpeed       precipProbability  0.196      0.2\n```\n:::\n\n\nPhew. With the data all tidied like that, we can make a correlogram with a heatmap. This is just like [the heatmap you made in session 4](https://datavizm20.classes.andrewheiss.com/example/04-example/#heatmap), but here we manipulate the fill scale a little so that it's diverging with three colors: a high value, a midpoint value, and a low value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(things_to_correlate_long, \n       aes(x = measure2, y = measure1, fill = cor)) +\n  geom_tile() +\n  geom_text(aes(label = nice_cor)) +\n  scale_fill_gradient2(low = \"#E16462\", mid = \"white\", high = \"#0D0887\",\n                       limits = c(-1, 1)) +\n  labs(x = NULL, y = NULL) +\n  coord_equal() +\n  theme_minimal() +\n  theme(panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/cor-heatmap-1.png){fig-align='center' width=480}\n:::\n:::\n\n\nInstead of using a heatmap, we can also use points, which encode the correlation information both as color *and* as size. To do that, we just need to switch `geom_tile()` to `geom_point()` and set the `size = cor` mapping:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(things_to_correlate_long, \n       aes(x = measure2, y = measure1, color = cor)) +\n  # Size by the absolute value so that -0.7 and 0.7 are the same size\n  geom_point(aes(size = abs(cor))) +\n  scale_color_gradient2(low = \"#E16462\", mid = \"white\", high = \"#0D0887\",\n                        limits = c(-1, 1)) +\n  scale_size_area(max_size = 15, limits = c(-1, 1), guide = \"none\") +\n  labs(x = NULL, y = NULL) +\n  coord_equal() +\n  theme_minimal() +\n  theme(panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/cor-points-1.png){fig-align='center' width=480}\n:::\n:::\n\n\n\n## Simple regression\n\nWe can also visualize the relationships between variables using regression. Simple regression is easy to visualize, since you're only working with an X and a Y. For instance, what's the relationship between humidity and high temperatures during the summer?\n\nFirst, let's filter the data to only look at the summer. We also add a column to scale up the humidity value—right now it's on a scale of 0-1 (for percentages), but when interpreting regression we talk about increases in whole units, so we'd talk about moving from 0% humidity to 100% humidity, which isn't helpful, so instead we multiply everything by 100 so we can talk about moving from 50% humidity to 51% humidity. We also scale up a couple other variables that we'll use in the larger model later.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nweather_atl_summer <- weather_atl %>% \n  filter(time >= \"2019-05-01\", time <= \"2019-09-30\") %>% \n  mutate(humidity_scaled = humidity * 100,\n         moonPhase_scaled = moonPhase * 100,\n         precipProbability_scaled = precipProbability * 100,\n         cloudCover_scaled = cloudCover * 100)\n```\n:::\n\n\nThen we can build a simple regression model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_simple <- lm(temperatureHigh ~ humidity_scaled, \n                   data = weather_atl_summer)\n\ntidy(model_simple, conf.int = TRUE)\n## # A tibble: 2 × 7\n##   term            estimate std.error statistic  p.value conf.low conf.high\n##   <chr>              <dbl>     <dbl>     <dbl>    <dbl>    <dbl>     <dbl>\n## 1 (Intercept)      104.       2.35       44.3  1.88e-88   99.5     109.   \n## 2 humidity_scaled   -0.241    0.0358     -6.74 3.21e-10   -0.312    -0.170\n```\n:::\n\n\nWe can interpret these coefficients like so:\n\n- The intercept shows that the average temperature when there's 0% humidity is 104°. There are no days with 0% humidity though, so we can ignore the intercept—it's really just here so that we can draw the line.\n- The coefficient for `humidity_scaled` shows that a one percent increase in humidity is associated with a 0.241° decrease in temperature, on average.\n\nVisualizing this model is simple, since there are only two variables:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(weather_atl_summer,\n       aes(x = humidity_scaled, y = temperatureHigh)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/plot-simple-model-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nAnd indeed, as humidity increases, temperatures decrease.\n\n## Coefficient plots\n\nBut if we use multiple variables in the model, it gets really hard to visualize the results since we're working with multiple dimensions. Instead, we can use coefficient plots to see the individual coefficients in the model.\n\nFirst, let's build a more complex model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_complex <- lm(temperatureHigh ~ humidity_scaled + moonPhase_scaled + \n                      precipProbability_scaled + windSpeed + pressure + cloudCover_scaled,\n                    data = weather_atl_summer)\ntidy(model_complex, conf.int = TRUE)\n## # A tibble: 7 × 7\n##   term                     estimate std.error statistic   p.value conf.low conf.high\n##   <chr>                       <dbl>     <dbl>     <dbl>     <dbl>    <dbl>     <dbl>\n## 1 (Intercept)              262.      125.         2.09  0.0380    14.8      510.    \n## 2 humidity_scaled           -0.111     0.0757    -1.47  0.143     -0.261      0.0381\n## 3 moonPhase_scaled           0.0116    0.0126     0.917 0.360     -0.0134     0.0366\n## 4 precipProbability_scaled   0.0356    0.0203     1.75  0.0820    -0.00458    0.0758\n## 5 windSpeed                 -1.78      0.414     -4.29  0.0000326 -2.59      -0.958 \n## 6 pressure                  -0.157     0.122     -1.28  0.203     -0.398      0.0854\n## 7 cloudCover_scaled         -0.0952    0.0304    -3.14  0.00207   -0.155     -0.0352\n```\n:::\n\n\nWe can interpret these coefficients like so:\n\n- Holding everything else constant, a 1% increase in humidity is associated with a 0.11° decrease in the high temperature, on average, but the effect is not statistically significant\n- Holding everything else constant, a 1% increase in moon visibility is associated with a 0.01° increase in the high temperature, on average, and the effect is not statistically significant\n- Holding everything else constant, a 1% increase in the probability of precipitation is associated with a 0.04° increase in the high temperature, on average, and the effect is not statistically significant\n- Holding everything else constant, a 1 mph increase in the wind speed is associated with a 1.8° decrease in the high temperature, on average, and the effect *is* statistically significant\n- Holding everything else constant, a 1 unit increase in barometric pressure is associated with a 0.15° decrease in the high temperature, on average, and the effect is not statistically significant\n- Holding everything else constant, a 1% increase in cloud cover is associated with a 0.01° decrease in the high temperature, on average, and the effect *is* statistically significant\n- The intercept is pretty useless. It shows that the predicted temperature will be 262° when humidity is 0%, the moon is invisible, there's no chance of precipitation, no wind, no barometric pressure, and no cloud cover. Yikes.\n\nTo plot all these things at once, we'll store the results of `tidy(model_complex)` as a data frame, remove the useless intercept, and plot it using `geom_pointrange()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_tidied <- tidy(model_complex, conf.int = TRUE) %>% \n  filter(term != \"(Intercept)\")\n\nggplot(model_tidied,\n       aes(x = estimate, y = term)) +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dotted\") +\n  geom_pointrange(aes(xmin = conf.low, xmax = conf.high)) + \n  labs(x = \"Coefficient estimate\", y = NULL) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/coef-plot-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nNeat! Now we can see how big these different coefficients are and how close they are to zero. Wind speed has a big significant effect on temperature. The others are all very close to zero.\n\n## Marginal effects plots\n\n::: {.callout-tip}\n### 2023 update!\n\nSince recording the video for this section, lots of things have changed in the R world to make finding predicted values and marginal effects *a lot* easier. (This is why I had you [read my guide to marginal things](https://www.andrewheiss.com/blog/2022/05/20/marginalia/) as part of the readings for this session.) [The {marginaleffects} R package](https://vincentarelbundock.github.io/marginaleffects/) makes it really nice and easy to get predicted values of an outcome while holding everything else constant—you don't need to plug values in manually anymore like this section shows.\n\nThere's an example of using {marginaleffects} [down below](#predicted-values-and-marginal-effects-in-2023).\n\n:::\n\nInstead of just looking at the coefficients, we can also see the effect of moving different variables up and down like sliders and switches. Remember that regression coefficients allow us to build actual mathematical formulas that predict the value of Y. The coefficients from `model_compex` yield the following big hairy ugly equation:\n\n$$\n\\begin{aligned}\n\\hat{\\text{High temperature}} =& 262 - 0.11 \\times \\text{humidity\\_scaled } \\\\\n& + 0.01 \\times \\text{moonPhase\\_scaled } + 0.04 \\times \\text{precipProbability\\_scaled } \\\\\n& - 1.78 \\times \\text{windSpeed} - 0.16 \\times \\text{pressure} - 0.095 \\times \\text{cloudCover\\_scaled}\n\\end{aligned}\n$$\n\nIf we plug in values for each of the explanatory variables, we can get the predicted value of high temperature, or $\\hat{y}$.\n\nThe `augment()` function in the {broom} library allows us to take a data frame of explanatory variable values, plug them into the model equation, and get predictions out. For example, let's set each of the variables to some arbitrary values (50% for humidity, moon phase, chance of rain, and cloud cover; 1000 for pressure, and 1 MPH for wind speed).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnewdata_example <- tibble(humidity_scaled = 50, moonPhase_scaled = 50, \n                          precipProbability_scaled = 50, windSpeed = 1, \n                          pressure = 1000, cloudCover_scaled = 50)\nnewdata_example\n## # A tibble: 1 × 6\n##   humidity_scaled moonPhase_scaled precipProbability_scaled windSpeed pressure cloudCover_scaled\n##             <dbl>            <dbl>                    <dbl>     <dbl>    <dbl>             <dbl>\n## 1              50               50                       50         1     1000                50\n```\n:::\n\n\nWe can plug these values into the model with `augment()`. The `se_fit` argument gives us standard errors for each prediction:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# I use select() here because augment() returns columns for all the explanatory\n# variables, and the .fitted column with the predicted value is on the far right\n# and gets cut off\naugment(model_complex, newdata = newdata_example, se_fit = TRUE) %>% \n  select(.fitted, .se.fit)\n## # A tibble: 1 × 2\n##   .fitted .se.fit\n##     <dbl>   <dbl>\n## 1    96.2    3.19\n```\n:::\n\n\nGiven these weather conditions, the predicted high temperature is 96.2°. Now you're an armchair meteorologist!\n\nWe can follow the same pattern to show how the predicted temperature changes as specific variables change across a whole range. Here, we create a data frame of possible wind speeds and keep all the other explanatory variables at their means:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnewdata <- tibble(windSpeed = seq(0, 8, 0.5),\n                  pressure = mean(weather_atl_summer$pressure),\n                  precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),\n                  moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),\n                  humidity_scaled = mean(weather_atl_summer$humidity_scaled),\n                  cloudCover_scaled = mean(weather_atl_summer$cloudCover_scaled))\nnewdata\n## # A tibble: 17 × 6\n##    windSpeed pressure precipProbability_scaled moonPhase_scaled humidity_scaled cloudCover_scaled\n##        <dbl>    <dbl>                    <dbl>            <dbl>           <dbl>             <dbl>\n##  1       0      1016.                     40.2             50.7            64.8              29.5\n##  2       0.5    1016.                     40.2             50.7            64.8              29.5\n##  3       1      1016.                     40.2             50.7            64.8              29.5\n##  4       1.5    1016.                     40.2             50.7            64.8              29.5\n##  5       2      1016.                     40.2             50.7            64.8              29.5\n##  6       2.5    1016.                     40.2             50.7            64.8              29.5\n##  7       3      1016.                     40.2             50.7            64.8              29.5\n##  8       3.5    1016.                     40.2             50.7            64.8              29.5\n##  9       4      1016.                     40.2             50.7            64.8              29.5\n## 10       4.5    1016.                     40.2             50.7            64.8              29.5\n## 11       5      1016.                     40.2             50.7            64.8              29.5\n## 12       5.5    1016.                     40.2             50.7            64.8              29.5\n## 13       6      1016.                     40.2             50.7            64.8              29.5\n## 14       6.5    1016.                     40.2             50.7            64.8              29.5\n## 15       7      1016.                     40.2             50.7            64.8              29.5\n## 16       7.5    1016.                     40.2             50.7            64.8              29.5\n## 17       8      1016.                     40.2             50.7            64.8              29.5\n```\n:::\n\n\nIf we feed this big data frame into `augment()`, we can get the predicted high temperature for each row. We can also use the `.se.fit` column to calculate the 95% confidence interval for each predicted value. We take the standard error, multiply it by -1.96 and 1.96 (or the quantile of the normal distribution at 2.5% and 97.5%), and add that value to the estimate.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npredicted_values <- augment(model_complex, \n                            newdata = newdata,\n                            se_fit = TRUE) %>% \n  mutate(conf.low = .fitted + (-1.96 * .se.fit),\n         conf.high = .fitted + (1.96 * .se.fit))\n\npredicted_values %>% \n  select(windSpeed, .fitted, .se.fit, conf.low, conf.high) %>% \n  head()\n## # A tibble: 6 × 5\n##   windSpeed .fitted .se.fit conf.low conf.high\n##       <dbl>   <dbl>   <dbl>    <dbl>     <dbl>\n## 1       0      95.3   1.63      92.2      98.5\n## 2       0.5    94.5   1.42      91.7      97.2\n## 3       1      93.6   1.22      91.2      96.0\n## 4       1.5    92.7   1.03      90.7      94.7\n## 5       2      91.8   0.836     90.1      93.4\n## 6       2.5    90.9   0.653     89.6      92.2\n```\n:::\n\n\nCool! Just looking at the data in the table, we can see that predicted temperature drops as windspeed increases. We can plot this to visualize the effect:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(predicted_values, aes(x = windSpeed, y = .fitted)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high),\n              fill = \"#BF3984\", alpha = 0.5) + \n  geom_line(linewidth = 1, color = \"#BF3984\") +\n  labs(x = \"Wind speed (MPH)\", y = \"Predicted high temperature (F)\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/mfx-plot-simple-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nWe just manipulated one of the model coefficients and held everything else at its mean. We can manipulate multiple variables too and encode them all on the graph. For instance, what is the effect of windspeed *and* cloud cover on the temperature?\n\nWe'll follow the same process, but vary both `windSpeed` and `cloudCover_scaled`. Instead of using `tibble()`, we use `exapnd_grid()`, which creates every combination of the variables we specify. Instead of varying cloud cover by every possible value (like from 0 to 100), we'll choose four possible cloud cover types: 0%, 33%, 66%, and 100%. Everything else will be at its mean.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnewdata_fancy <- expand_grid(windSpeed = seq(0, 8, 0.5),\n                             pressure = mean(weather_atl_summer$pressure),\n                             precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),\n                             moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),\n                             humidity_scaled = mean(weather_atl_summer$humidity_scaled),\n                             cloudCover_scaled = c(0, 33, 66, 100))\nnewdata_fancy\n## # A tibble: 68 × 6\n##    windSpeed pressure precipProbability_scaled moonPhase_scaled humidity_scaled cloudCover_scaled\n##        <dbl>    <dbl>                    <dbl>            <dbl>           <dbl>             <dbl>\n##  1       0      1016.                     40.2             50.7            64.8                 0\n##  2       0      1016.                     40.2             50.7            64.8                33\n##  3       0      1016.                     40.2             50.7            64.8                66\n##  4       0      1016.                     40.2             50.7            64.8               100\n##  5       0.5    1016.                     40.2             50.7            64.8                 0\n##  6       0.5    1016.                     40.2             50.7            64.8                33\n##  7       0.5    1016.                     40.2             50.7            64.8                66\n##  8       0.5    1016.                     40.2             50.7            64.8               100\n##  9       1      1016.                     40.2             50.7            64.8                 0\n## 10       1      1016.                     40.2             50.7            64.8                33\n## # ℹ 58 more rows\n```\n:::\n\n\nNotice now that `windSpeed` repeats four times (0, 0, 0, 0, 0.5, 0.5, etc.), since there are four possible `cloudCover_scaled` values (0, 33, 66, 100). \n\nWe can plot this now, just like before, with wind speed on the x-axis, the predicted temperature on the y-axis, and colored and faceted by cloud cover:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npredicted_values_fancy <- augment(model_complex, \n                                  newdata = newdata_fancy, \n                                  se_fit = TRUE) %>% \n  mutate(conf.low = .fitted + (-1.96 * .se.fit),\n         conf.high = .fitted + (1.96 * .se.fit)) %>% \n  # Make cloud cover a categorical variable so we can facet with it\n  mutate(cloudCover_scaled = factor(cloudCover_scaled))\n\nggplot(predicted_values_fancy, aes(x = windSpeed, y = .fitted)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = cloudCover_scaled),\n              alpha = 0.5) + \n  geom_line(aes(color = cloudCover_scaled), linewidth = 1) +\n  labs(x = \"Wind speed (MPH)\", y = \"Predicted high temperature (F)\") +\n  theme_minimal() +\n  guides(fill = \"none\", color = \"none\") +\n  facet_wrap(vars(cloudCover_scaled), nrow = 1)\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/mfx-complex-1.png){fig-align='center' width=864}\n:::\n:::\n\n\nThat's so neat! Temperatures go down slightly as cloud cover increases. If we wanted to improve the model, we'd add an interaction term between cloud cover and windspeed so that each line would have a different slope in addition to a different intercept, but that's beyond the scope of this class.\n\n\n## Predicted values and marginal effects in 2023\n\nInstead of using `expand_grid()` and `augment()` to create and plug in a mini dataset of variables to move up and down, we can use [the {marginaleffects} package](https://vincentarelbundock.github.io/marginaleffects/) to simplify life!\n\nRemember above where we wanted to see the effect of wind speed on temperature while holding all other variables in the model constant. We had to create a small data frame (`newdata`) with columns for each of the variables in the model, with everything except `windSpeed` set to their averages. We then plugged `newdata` into the model with `augment()` and calculated the confidence interval around each predicted value using `mutate()`. It's a fairly involved process, but it works: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Make model\nmodel_complex <- lm(temperatureHigh ~ humidity_scaled + moonPhase_scaled + \n                      precipProbability_scaled + windSpeed + pressure + cloudCover_scaled,\n                    data = weather_atl_summer)\n\n# Make mini dataset\nnewdata <- tibble(windSpeed = seq(0, 8, 0.5),\n                  pressure = mean(weather_atl_summer$pressure),\n                  precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),\n                  moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),\n                  humidity_scaled = mean(weather_atl_summer$humidity_scaled),\n                  cloudCover_scaled = mean(weather_atl_summer$cloudCover_scaled))\n\n# Plug mini dataset into model\npredicted_values <- augment(model_complex, \n                            newdata = newdata,\n                            se_fit = TRUE) %>% \n  mutate(conf.low = .fitted + (-1.96 * .se.fit),\n         conf.high = .fitted + (1.96 * .se.fit))\n\n# Look at predicted values\npredicted_values %>% \n  select(windSpeed, .fitted, .se.fit, conf.low, conf.high) %>% \n  head()\n## # A tibble: 6 × 5\n##   windSpeed .fitted .se.fit conf.low conf.high\n##       <dbl>   <dbl>   <dbl>    <dbl>     <dbl>\n## 1       0      95.3   1.63      92.2      98.5\n## 2       0.5    94.5   1.42      91.7      97.2\n## 3       1      93.6   1.22      91.2      96.0\n## 4       1.5    92.7   1.03      90.7      94.7\n## 5       2      91.8   0.836     90.1      93.4\n## 6       2.5    90.9   0.653     89.6      92.2\n```\n:::\n\n\nThe {marginaleffects} package makes this far easier. We can use the `predictions()` function to generate, um, predictions. We still need to feed it a smaller dataset of variables to manipulate, but if we use the `datagrid()` function, we *only have to specify the variables we want to move*. It will automatically use the averages or typical values for all other variables in the model. It will also automatically create confidence intervals for each prediction—no need for the `mutate(conf.low = .fitted + (-1.96 * .se.fit))` math that we did previously.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(marginaleffects)\n## Warning: package 'marginaleffects' was built under R version 4.2.3\n\n# Calculate predictions across a range of windSpeed\npredicted_values_easy <- predictions(\n  model_complex,\n  newdata = datagrid(windSpeed = seq(0, 8, 0.5))\n)\n\n# Look at predicted values\npredicted_values_easy %>%\n  select(windSpeed, estimate, std.error, conf.low, conf.high)\n## \n##  Estimate Std. Error CI low CI high\n##      95.3      1.626   92.2    98.5\n##      94.5      1.425   91.7    97.2\n##      93.6      1.225   91.2    96.0\n##      92.7      1.028   90.7    94.7\n##      91.8      0.836   90.1    93.4\n##      90.9      0.653   89.6    92.2\n##      90.0      0.490   89.0    91.0\n##      89.1      0.374   88.4    89.9\n##      88.2      0.354   87.5    88.9\n##      87.3      0.443   86.5    88.2\n##      86.5      0.594   85.3    87.6\n##      85.6      0.772   84.1    87.1\n##      84.7      0.961   82.8    86.6\n##      83.8      1.157   81.5    86.1\n##      82.9      1.356   80.2    85.6\n##      82.0      1.557   79.0    85.1\n##      81.1      1.759   77.7    84.6\n## \n## Columns: windSpeed, estimate, std.error, conf.low, conf.high\n```\n:::\n\n\nWe can then plot this really easily too:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(predicted_values_easy, aes(x = windSpeed, y = estimate)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high),\n              fill = \"#BF3984\", alpha = 0.5) + \n  geom_line(linewidth = 1, color = \"#BF3984\") +\n  labs(x = \"Wind speed (MPH)\", y = \"Predicted high temperature (F)\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/mfx-plot-easy-pred-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nThis works when moving multiple variables at the same time, too. Earlier we used `expand_grid()` to create a mini dataset of different values for both `windSpeed` and `cloudCover`, while holding all the other variables at their means. Here's how to do that with the much easier `predictions()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npredicted_values_fancy_easy <- predictions(\n  model_complex,\n  newdata = datagrid(windSpeed = seq(0, 8, 0.5),\n                     cloudCover_scaled = c(0, 33, 66, 100))) %>%\n  # Make cloud cover a categorical variable so we can facet with it\n  mutate(cloudCover_scaled = factor(cloudCover_scaled))\n\nggplot(predicted_values_fancy_easy, aes(x = windSpeed, y = estimate)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = cloudCover_scaled),\n              alpha = 0.5) + \n  geom_line(aes(color = cloudCover_scaled), linewidth = 1) +\n  labs(x = \"Wind speed (MPH)\", y = \"Predicted high temperature (F)\") +\n  theme_minimal() +\n  guides(fill = \"none\", color = \"none\") +\n  facet_wrap(vars(cloudCover_scaled), nrow = 1)\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/mfx-plot-complex-pred-1.png){fig-align='center' width=864}\n:::\n:::\n\n\nThat's it! `predictions()` makes this so easy!\n\nIf we're interested in the slopes (or marginal effects) of these lines, we can calculate these really easily too with the `slopes()` function. For instance, here are the predicted temperatures when just manipulating wind speed:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(predicted_values_easy, aes(x = windSpeed, y = estimate)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high),\n              fill = \"#BF3984\", alpha = 0.5) + \n  geom_line(linewidth = 1, color = \"#BF3984\") +\n  labs(x = \"Wind speed (MPH)\", y = \"Predicted high temperature (F)\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/mfx-plot-easy-pred-again-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nIf we want to see what the slope of that line is when wind speed is 2, 4 and 6, we can use `slopes()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nslopes(model_complex, \n  newdata = datagrid(windSpeed = c(2, 4, 6)), \n  variables = \"windSpeed\") %>%\n  # This creates a ton of extra columns so we'll just look at a few\n  select(term, windSpeed, estimate, std.error, p.value, conf.low, conf.high, predicted)\n## \n##       Term Estimate Std. Error Pr(>|z|) CI low CI high\n##  windSpeed    -1.78      0.414   <0.001  -2.59  -0.964\n##  windSpeed    -1.78      0.415   <0.001  -2.59  -0.962\n##  windSpeed    -1.78      0.414   <0.001  -2.59  -0.966\n## \n## Columns: term, windSpeed, estimate, std.error, p.value, conf.low, conf.high, predicted\n```\n:::\n\n\nThe `estimate` column here shows that slope at each of those values of `windSpeed` is -1.8, meaning a 1-MPH increase in wind speed is associated with a nearly 2° decrease in predicted high temperature, on average. That's not super exciting though, since the predicted values create a nice straight line, with the same slope across the whole range of the line. It's also the same number we get from the model coefficient—run `tidy(model_complex)` and you'll see that the coefficient for `windSpeed` is -1.78. Since everything is linear here, using `slopes()` isn't that important.\n\nFor bonus fun and excitement, let's make an even more complex model with some non-linear curvy stuff and some interaction terms. We'll include both wind speed and wind speed squared (since maybe higher wind speeds have a larger effect on predicted temperatures), and the interaction between wind speed and cloud cover (since maybe temperature behaves differently at different combinations of wind speed and cloud cover). Again, I'm not a meteorologist so this model is *definitely wrong*, but it gives us some neat moving parts we can play with.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Make model\n# We square windSpeed with I(windSpeed^2). The I() function lets you do math\n# with regression terms.\n# We make an interaction term with *\nmodel_wild <- lm(temperatureHigh ~ humidity_scaled + moonPhase_scaled + \n                   precipProbability_scaled + windSpeed + I(windSpeed^2) + \n                   pressure + cloudCover_scaled + (windSpeed * cloudCover_scaled),\n                 data = weather_atl_summer)\n\ntidy(model_wild)\n## # A tibble: 9 × 5\n##   term                         estimate std.error statistic p.value\n##   <chr>                           <dbl>     <dbl>     <dbl>   <dbl>\n## 1 (Intercept)                 264.       126.        2.10    0.0374\n## 2 humidity_scaled              -0.122      0.0767   -1.58    0.115 \n## 3 moonPhase_scaled              0.0109     0.0128    0.849   0.397 \n## 4 precipProbability_scaled      0.0390     0.0207    1.88    0.0620\n## 5 windSpeed                     0.113      2.58      0.0438  0.965 \n## 6 I(windSpeed^2)               -0.198      0.330    -0.601   0.549 \n## 7 pressure                     -0.162      0.123    -1.32    0.190 \n## 8 cloudCover_scaled            -0.0691     0.0829   -0.833   0.406 \n## 9 windSpeed:cloudCover_scaled  -0.00688    0.0196   -0.351   0.726\n```\n:::\n\n\nWe have some strange new regression coefficients now. We have two coefficients for wind speed: `windSpeed` and `I(windSpeed^2)`. We also have a coefficient for the interaction term `windspeed:cloudCover_scaled`. **We cannot interpret these individually**. If we want to know the effect of wind speed on high temperatures, we have to incorporate all three of these new coefficients simultaneously. Fortunately `predictions()` and `slopes()` both handle that for us automatically.\n\nLet's plot the predictions to see that everything is more curvy now (and differently curved across different levels of cloud cover).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npredicted_values_wild <- predictions(\n  model_wild, \n  newdata = datagrid(windSpeed = seq(0, 8, 0.5),\n                     cloudCover_scaled = c(0, 33, 66, 100))) %>%\n  # Make cloud cover a categorical variable so we can facet with it\n  mutate(cloudCover_scaled = factor(cloudCover_scaled))\n\nggplot(predicted_values_wild, aes(x = windSpeed, y = estimate)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = cloudCover_scaled),\n              alpha = 0.5) + \n  geom_line(aes(color = cloudCover_scaled), linewidth = 1) +\n  labs(x = \"Wind speed (MPH)\", y = \"Predicted high temperature (F)\") +\n  theme_minimal() +\n  guides(fill = \"none\", color = \"none\") +\n  facet_wrap(vars(cloudCover_scaled), nrow = 1)\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/mfx-predictions-wild-1.png){fig-align='center' width=864}\n:::\n:::\n\n\nThat's neat! At all the different levels of cloud cover, the wind speed trend is fairly shallow (and even pretty flat when cloud cover is 0 or 33) at low levels of wind speed. The line drops fairly quickly as wind speed increases though. Let's get some exact numbers with `marginaleffects()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nslopes(model_wild, \n  newdata = datagrid(windSpeed = c(2, 4, 6),\n    cloudCover_scaled = c(0, 33, 66, 100)), \n  variables = \"windSpeed\") %>%\n  # This creates a ton of extra columns so we'll just look at a few\n  select(term, windSpeed, estimate, std.error, p.value, conf.low, conf.high, predicted)\n## \n##       Term Estimate Std. Error Pr(>|z|) CI low CI high\n##  windSpeed   -0.681      1.477   0.6449  -3.58  2.2145\n##  windSpeed   -0.908      1.669   0.5864  -4.18  2.3627\n##  windSpeed   -1.135      2.050   0.5800  -5.15  2.8838\n##  windSpeed   -1.368      2.561   0.5931  -6.39  3.6515\n##  windSpeed   -1.475      0.694   0.0335  -2.83 -0.1150\n##  windSpeed   -1.702      0.421   <0.001  -2.53 -0.8755\n##  windSpeed   -1.928      0.837   0.0212  -3.57 -0.2880\n##  windSpeed   -2.162      1.462   0.1391  -5.03  0.7030\n##  windSpeed   -2.268      1.801   0.2078  -5.80  1.2613\n##  windSpeed   -2.495      1.434   0.0817  -5.31  0.3144\n##  windSpeed   -2.722      1.305   0.0369  -5.28 -0.1651\n##  windSpeed   -2.956      1.488   0.0470  -5.87 -0.0394\n## \n## Columns: term, windSpeed, estimate, std.error, p.value, conf.low, conf.high, predicted\n```\n:::\n\n\nPhew, we have 12 different slopes here. Let's talk through a few of them to get the intuition. If cloud cover is 0 and wind speed is 2 MPH, moving from 2 to 3 MPH is associated with a -0.68° decrease in high temperature on average (see the `estimate` column in the first row in the table). If the existing wind speed is 6 MPH, moving from 6 to 7 is associated with a -2.27° decrease in high temperature on average (see the `estimate` column in the 9th row of the table). The slope is steeper and more negative when the wind is faster, so changes in temperature are more dramatic. Because we have an interaction with cloud cover, the slope also changes at different levels of cloud cover. At 2 MPH of wind, the slope is -0.68° when cloud cover is 0 (first row), but -1.37° when cloud cover is 100 (4th row). \n\nFinally, we can visualize how these slopes change across wind speed and cloud cover by plotting them:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nslopes_wild <- slopes(\n  model_wild, \n  newdata = datagrid(windSpeed = seq(0, 6, by = 0.1),\n                     cloudCover_scaled = c(0, 33, 66, 100)), \n  variables = \"windSpeed\") %>%\n  mutate(cloudCover_scaled = factor(cloudCover_scaled))\n\nggplot(slopes_wild, aes(x = windSpeed, y = estimate)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = cloudCover_scaled),\n              alpha = 0.5) +\n  geom_line(aes(color = cloudCover_scaled), linewidth = 1) +\n  labs(x = \"Wind speed (MPH)\", y = \"Slope (marginal effect) of wind speed\",\n       title = \"Marginal effect of wind speed across levels of cloud cover\",\n       subtitle = \"These are *slopes*, not predicted values\") +\n  theme_minimal() +\n  guides(fill = \"none\", color = \"none\") +\n  facet_wrap(vars(cloudCover_scaled), nrow = 1)\n```\n\n::: {.cell-output-display}\n![](07-example_files/figure-html/plot-mfx-slopes-wild-1.png){fig-align='center' width=864}\n:::\n:::\n",
    "supporting": [
      "07-example_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}