{
  "hash": "c96f2e76170217801a78b4eec728a3f3",
  "result": {
    "markdown": "---\ntitle: \"Week 7 tips and FAQs\"\ndate: \"2023-10-10T12:04\"\ncategories: [FAQs]\ntoc-depth: 4\n---\n\n\n\n\nHi everyone!\n\nI just finished grading all your exercises from week 7 and am happy with how you've been doing! I have a few quick tips and tricks and suggestions here based on lots of the feedback I gave. Enjoy!\n\n\n### I tried to knit my document and got an error about duplicate chunk labels. Why?\n\nYou can ([and should!](/resource/rmarkdown.qmd#chunk-names)) name your R code chunks—[see here for more about how and why](/resource/rmarkdown.qmd#chunk-names). All chunk names must be unique, though. \n\nOften you'll copy and paste a chunk from earlier in your document to later, like to make a second plot based on the first. That's fine—just make sure that you change the chunk name.\n\nIf there are chunks with repeated names, R will yell at you:\n\n![Duplicated chunk names](img/knitr-duplicate-chunks.png)\n\nTo fix it, change the name of one of the duplicated names to something unique:\n\n![Unique chunk names](img/knitr-different-names.png)\n\n\n### I tried calculating something with `sum()` or `cor()` and R gave me NA instead of a number. Why?\n\nThis nearly always happens because of missing values. Let's make a quick little dataset to illustrate what's going on (and how to fix it):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nexample <- tibble(\n  x = c(1, 2, 3, 4, 5),\n  y = c(6, 7, NA, 9, 10),\n  z = c(2, 6, 5, 7, 3)\n)\n\nexample\n## # A tibble: 5 × 3\n##       x     y     z\n##   <dbl> <dbl> <dbl>\n## 1     1     6     2\n## 2     2     7     6\n## 3     3    NA     5\n## 4     4     9     7\n## 5     5    10     3\n```\n:::\n\n\nThe `y` column has a missing value (`NA`), which will mess up any math we do.\n\nWithout running any code, what's the average of the `x` column? We can find that with math (add all the numbers up and divide by how many numbers there are):\n\n$$\n\\frac{1 + 2 + 3 + 4 + 5}{5} = 3\n$$\n\nNeat. We can confirm with R:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# With dplyr\nexample %>% \n  summarize(avg = mean(x))\n## # A tibble: 1 × 1\n##     avg\n##   <dbl>\n## 1     3\n\n# With base R\nmean(example$x)\n## [1] 3\n```\n:::\n\n\nWhat's the average of the `y` column? Math time:\n\n$$\n\\frac{6 + 7 + \\text{?} + 9 + 10}{5} = \\text{Who even knows}\n$$\n\nWe have no way of knowing what the average is because of that missing value.\n\nIf we try it with R, it gives us NA instead of a number:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample %>% \n  summarize(avg = mean(y))\n## # A tibble: 1 × 1\n##     avg\n##   <dbl>\n## 1    NA\n```\n:::\n\n\nTo fix this, we can tell R to remove all the missing values from the column before calculating the average so that it does this:\n\n$$\n\\frac{6 + 7 + 9 + 10}{4} = 8\n$$\n\nInclude the argument `na.rm = TRUE` to do that:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample %>% \n  summarize(avg = mean(y, na.rm = TRUE))\n## # A tibble: 1 × 1\n##     avg\n##   <dbl>\n## 1     8\n```\n:::\n\n\nThis works for lots of R's calculating functions, like `sum()`, `min()`, `max()`, `sd()`, `median()`, `mean()`, and so on:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample %>% \n  summarize(\n    total = sum(y, na.rm = TRUE),\n    avg = mean(y, na.rm = TRUE),\n    median = median(y, na.rm = TRUE),\n    min = min(y, na.rm = TRUE),\n    max = max(y, na.rm = TRUE),\n    std_dev = sd(y, na.rm = TRUE)\n  )\n## # A tibble: 1 × 6\n##   total   avg median   min   max std_dev\n##   <dbl> <dbl>  <dbl> <dbl> <dbl>   <dbl>\n## 1    32     8      8     6    10    1.83\n```\n:::\n\n\nThis works a little differently with `cor()` because you're working with multiple columns instead of just one. If there are any missing values in any of the columns you're correlating, you'll get NA for the columns that use it. Here, we have a correlation between `x` and `z` because there are no missing values in either of those, but we get NA for the correlation between `x` and `y` and between `z` and `y`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample %>% \n  cor()\n##           x  y         z\n## x 1.0000000 NA 0.2287479\n## y        NA  1        NA\n## z 0.2287479 NA 1.0000000\n```\n:::\n\n\nAdding `na.rm` to `cor()` doesn't work because `cor()` doesn't actually have an argument for `na.rm`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample %>%\n  cor(na.rm = TRUE)\n## Error in cor(., na.rm = TRUE): unused argument (na.rm = TRUE)\n```\n:::\n\n\nInstead, if you look at the documentation for `cor()` (run `?cor` in your R console or search for it in the Help panel in RStudio), you'll see an argument named `use` instead. By default it will use all the rows in the data (`use = \"everything\"`), but we can change it to `use = \"complete.obs\"`. This will remove all rows where something is missing before calculating the correlation:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample %>%\n  cor(use = \"complete.obs\")\n##           x         y         z\n## x 1.0000000 1.0000000 0.2300895\n## y 1.0000000 1.0000000 0.2300895\n## z 0.2300895 0.2300895 1.0000000\n```\n:::\n\n\n\n### I want my bars to be sorted in my plot. How can I control their order?\n\nSorting categories by different values is important for showing trends in your data. By default, R will plot categorical variables in alphabetical order, but often you'll want these categories to use some sort of numeric order, likely based on a different column. \n\nThere are a few different ways to sort categories. First, let's make a summarized dataset of the total population in each continent in 2007 (using our trusty ol' gapminder data):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(gapminder)\n## Warning: package 'gapminder' was built under R version 4.2.3\n\n# Find the total population in each continent in 2007\npopulation_by_continent <- gapminder %>% \n  filter(year == 2007) %>% \n  group_by(continent) %>% \n  summarize(total_population = sum(pop))\npopulation_by_continent\n## # A tibble: 5 × 2\n##   continent total_population\n##   <fct>                <dbl>\n## 1 Africa           929539692\n## 2 Americas         898871184\n## 3 Asia            3811953827\n## 4 Europe           586098529\n## 5 Oceania           24549947\n```\n:::\n\n\nBy default the continents will be in alphabetic order:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(\n  population_by_continent,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")  # The legend is redundant because of the x-axis\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-gapminder-alphabetic-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nIn this case it's more useful to plot these in order of total population. My favorite approach for this is to (1) sort the data how I want it with `arrange()` and (2) lock the order of the category in place with `fct_inorder()`. Note how the mini dataset is now sorted and Oceania comes first:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population\n  arrange(total_population) %>% \n  # Make continent use the order it's currently in\n  mutate(continent = fct_inorder(continent))\nplot_data_sorted\n## # A tibble: 5 × 2\n##   continent total_population\n##   <fct>                <dbl>\n## 1 Oceania           24549947\n## 2 Europe           586098529\n## 3 Americas         898871184\n## 4 Africa           929539692\n## 5 Asia            3811953827\n```\n:::\n\n\nIf we plot it, the continents will be in order:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-gapminder-sorted-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nThis plots the continents in reverse order, with Oceania on the left. We can reverse this by either arranging the data in descending population order, or by using `fct_rev()` to reverse the continent order:\n\n::: {.panel-tabset}\n### Sort in descending order\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population in descending order\n  arrange(desc(total_population)) %>% \n  # Lock in the continent order\n  mutate(continent = fct_inorder(continent))\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-gapminder-desc-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n### Use `fct_rev()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_data_sorted <- population_by_continent %>% \n  # Sort by population in ascending order\n  arrange(total_population) %>% \n  # Lock in the continent order\n  mutate(continent = fct_inorder(continent))\n\nggplot(\n  plot_data_sorted,\n  # Reverse the continent order with fct_rev()\n  aes(x = fct_rev(continent), y = total_population, fill = fct_rev(continent))\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-gapminder-fct-rev-1.png){fig-align='center' width=90%}\n:::\n:::\n\n:::\n\nAn alternative to the two-step `arrange() %>% mutate(blah = fct_inorder(blah))` is to use `fct_reorder()`, which takes two arguments: (1) the column you want to be reordered and (2) the column you want to sort it by:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_data_sorted <- population_by_continent %>% \n  # Sort continent by total_population in descending order\n  mutate(continent = fct_reorder(continent, total_population, .desc = TRUE))\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-gapminder-fct-reorder-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nThat's only one line instead of two, which is nice, but I tend to be fan of the two step approach because it's more explicit and gives me more control over sorting. For instance, here I want all the gapminder countries to be sorted by year (descending), continent, and life expectancy so we can see descending life expectancy within each continent over time. \n\nI'm sure there's a way to sort by multiple columns in different orders like this with `fct_reorder()`, but I don't know how. Plus, if I run this `super_sorted_data` code up until the end of `arrange()`, I can look at it in RStudio to make sure all the ordering I want is right. That's harder to do with `fct_reorder()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsuper_sorted_data <- gapminder %>% \n  filter(year >= 1997) %>% \n  # Get the countries in order of year (descending), continent, and life expectancy\n  arrange(desc(year), continent, lifeExp) %>%\n  # Lock the country name order in place + lock the year in place\n  mutate(\n    country = fct_inorder(country),\n    # year is currently a number, so we need to change it to a factor before\n    # reordering it\n    year = fct_inorder(factor(year))\n  )\n\nggplot(super_sorted_data, aes(y = country, x = lifeExp, fill = continent)) +\n  geom_col() +\n  facet_wrap(vars(year)) +\n  # Reverse the order legend so that Oceania is at the top, since it's at the\n  # top in the plot\n  guides(fill = guide_legend(reverse = TRUE)) +\n  theme_minimal() +\n  # Remove country names and y-axis gridlines + put legend on the bottom\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"bottom\"\n  )\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/gapminder-wild-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nYou can also specify any arbitrary category order with `fct_relevel()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_data_sorted <- population_by_continent %>% \n  # Use this specific continent order\n  mutate(continent = fct_relevel(\n    continent, \n    c(\"Asia\", \"Oceania\", \"Europe\", \"Americas\", \"Africa\"))\n  )\n\nggplot(\n  plot_data_sorted,\n  aes(x = continent, y = total_population, fill = continent)\n) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-gapminder-arbitrary-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### My data has full US state names but I want to use abbreviations (or regions). Is there a way to automatically convert from names to something else?\n\nYep! R has a few state-related variables built in (run `?state` in your R console to see them all):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstate.name\n##  [1] \"Alabama\"        \"Alaska\"         \"Arizona\"        \"Arkansas\"      \n##  [5] \"California\"     \"Colorado\"       \"Connecticut\"    \"Delaware\"      \n##  [9] \"Florida\"        \"Georgia\"        \"Hawaii\"         \"Idaho\"         \n## [13] \"Illinois\"       \"Indiana\"        \"Iowa\"           \"Kansas\"        \n## [17] \"Kentucky\"       \"Louisiana\"      \"Maine\"          \"Maryland\"      \n## [21] \"Massachusetts\"  \"Michigan\"       \"Minnesota\"      \"Mississippi\"   \n## [25] \"Missouri\"       \"Montana\"        \"Nebraska\"       \"Nevada\"        \n## [29] \"New Hampshire\"  \"New Jersey\"     \"New Mexico\"     \"New York\"      \n## [33] \"North Carolina\" \"North Dakota\"   \"Ohio\"           \"Oklahoma\"      \n## [37] \"Oregon\"         \"Pennsylvania\"   \"Rhode Island\"   \"South Carolina\"\n## [41] \"South Dakota\"   \"Tennessee\"      \"Texas\"          \"Utah\"          \n## [45] \"Vermont\"        \"Virginia\"       \"Washington\"     \"West Virginia\" \n## [49] \"Wisconsin\"      \"Wyoming\"\nstate.abb\n##  [1] \"AL\" \"AK\" \"AZ\" \"AR\" \"CA\" \"CO\" \"CT\" \"DE\" \"FL\" \"GA\" \"HI\" \"ID\" \"IL\" \"IN\" \"IA\"\n## [16] \"KS\" \"KY\" \"LA\" \"ME\" \"MD\" \"MA\" \"MI\" \"MN\" \"MS\" \"MO\" \"MT\" \"NE\" \"NV\" \"NH\" \"NJ\"\n## [31] \"NM\" \"NY\" \"NC\" \"ND\" \"OH\" \"OK\" \"OR\" \"PA\" \"RI\" \"SC\" \"SD\" \"TN\" \"TX\" \"UT\" \"VT\"\n## [46] \"VA\" \"WA\" \"WV\" \"WI\" \"WY\"\nstate.region\n##  [1] South         West          West          South         West         \n##  [6] West          Northeast     South         South         South        \n## [11] West          West          North Central North Central North Central\n## [16] North Central South         South         Northeast     South        \n## [21] Northeast     North Central North Central South         North Central\n## [26] West          North Central West          Northeast     Northeast    \n## [31] West          Northeast     South         North Central North Central\n## [36] South         West          Northeast     Northeast     South        \n## [41] North Central South         South         West          Northeast    \n## [46] South         West          South         North Central West         \n## Levels: Northeast South North Central West\n```\n:::\n\n\nThese aren't datasets—they're single vectors—but you can make a little dataset with columns for each of those details, like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstate_details <- tibble(\n  state = state.name,\n  state_abb = state.abb,\n  state_division = state.division,\n  state_region = state.region\n) %>% \n  # Add DC manually\n  add_row(\n    state = \"Washington, DC\",\n    state_abb = \"DC\",\n    state_division = \"South Atlantic\",\n    state_region = \"South\"\n  )\nstate_details\n## # A tibble: 51 × 4\n##    state       state_abb state_division     state_region\n##    <chr>       <chr>     <chr>              <chr>       \n##  1 Alabama     AL        East South Central South       \n##  2 Alaska      AK        Pacific            West        \n##  3 Arizona     AZ        Mountain           West        \n##  4 Arkansas    AR        West South Central South       \n##  5 California  CA        Pacific            West        \n##  6 Colorado    CO        Mountain           West        \n##  7 Connecticut CT        New England        Northeast   \n##  8 Delaware    DE        South Atlantic     South       \n##  9 Florida     FL        South Atlantic     South       \n## 10 Georgia     GA        South Atlantic     South       \n## # ℹ 41 more rows\n```\n:::\n\n\nYou can join this dataset to any data you have that has state names or state abbreviations. Joining the data will bring all the columns from `state_details` into your data wherever rows match. You'll [learn a lot more about joining things in sesison 12 too](/lesson/12-lesson.qmd).\n\nFor instance, imagine you have a dataset that looks like this, similar to the unemployment data from exercise 8:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsome_state_data <- tribble(\n  ~state, ~something,\n  \"Wyoming\", 5,\n  \"North Carolina\", 9,\n  \"Nevada\", 10,\n  \"Georgia\", 3,\n  \"Rhode Island\", 1,\n  \"Washington, DC\", 6\n)\nsome_state_data\n## # A tibble: 6 × 2\n##   state          something\n##   <chr>              <dbl>\n## 1 Wyoming                5\n## 2 North Carolina         9\n## 3 Nevada                10\n## 4 Georgia                3\n## 5 Rhode Island           1\n## 6 Washington, DC         6\n```\n:::\n\n\nWe can merge in (or join) the `state_details` data so that we add columns for abbreviation, region, and so on, using `left_join()` (again, [see lesson 12 for more about all this](/lesson/12-lesson.qmd)):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Join the state details\ndata_with_state_details <- some_state_data %>% \n  left_join(state_details, by = join_by(state))\ndata_with_state_details\n## # A tibble: 6 × 5\n##   state          something state_abb state_division state_region\n##   <chr>              <dbl> <chr>     <chr>          <chr>       \n## 1 Wyoming                5 WY        Mountain       West        \n## 2 North Carolina         9 NC        South Atlantic South       \n## 3 Nevada                10 NV        Mountain       West        \n## 4 Georgia                3 GA        South Atlantic South       \n## 5 Rhode Island           1 RI        New England    Northeast   \n## 6 Washington, DC         6 DC        South Atlantic South\n```\n:::\n\n\nNow your `data_with_state_details` data has new columns for abbreviations, divisions, regions, and everything else that was in `state_details`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Use it\nggplot(\n  data_with_state_details, \n  aes(x = state_abb, y = something, fill = state_region)\n) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-state-abbreviations-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nAnd for fun, we can fix the ordering:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Fix the ordering\ndata_with_state_details <- some_state_data %>% \n  left_join(state_details, by = join_by(state)) %>% \n  arrange(desc(something)) %>% \n  mutate(state_abb = fct_inorder(state_abb))\n\nggplot(\n  data_with_state_details, \n  aes(x = state_abb, y = something, fill = state_region)\n) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](2023-10-10_faqs-week-07_files/figure-html/plot-state-abbreviations-ordering-1.png){fig-align='center' width=90%}\n:::\n:::\n",
    "supporting": [
      "2023-10-10_faqs-week-07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}