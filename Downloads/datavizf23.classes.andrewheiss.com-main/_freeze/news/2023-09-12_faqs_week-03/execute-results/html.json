{
  "hash": "d91ac85574b6e5a15c07c49096837dce",
  "result": {
    "markdown": "---\ntitle: \"Week 3 FAQs\"\ndate: \"2023-09-12T20:14\"\ncategories: [FAQs]\ntoc-depth: 4\n---\n\n\n\n\n\n\nHi everyone!\n\nMany of you had similar questions and I left lots of similar comments and tips on iCollege, so I’ve compiled the most common issues here. There are a bunch here, but they’re hopefully all useful.\n\n\n### Why are my axis labels all crowded and on top of each other? How do I fix that?\n\nThis was a common problem with the LOTR data and it will be a problem with exercise 4 (and future assignments too)—categories on the x-axis often overlap when you knit your document. That’s because there’s not enough room to fit them all comfortably in a standard image size. Fortunately there are a few quick and easy ways to fix this, such as changing the width of the image (see below), rotating the labels, dodging the labels, or (my favorite!) automatically adding line breaks to the labels so they don’t overlap. [This blog post](https://www.andrewheiss.com/blog/2022/06/23/long-labels-ggplot/) (by me) has super quick examples of all these different (easy!) approaches.\n\n\n### How can I add a line break to the text in my plot?\n\nIf you don't want to use the fancier techniques from [the blog post about long labels](https://www.andrewheiss.com/blog/2022/06/23/long-labels-ggplot/), a quick and easy way to deal with longer text is to manually insert a linebreak yourself. This is super easy: include a `\\n` where you want a new line:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Everyone's favorite\\nexample plot\",\n    x = \"Displacement\\n(proxy for car weight)\",\n    y = \"MPG\\n(highway)\",\n    color = \"Drive\"\n  )\n```\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/plot-line-break-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### How can I control the dimensions of my figures?\n\nBy default, R creates plots that are 7″×7″ squares:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/initial-square-plot-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nOften, though, those plots are excessively large and can result in text that is too small and dimensions that feel off. You generally want to have better control over the dimensions of the figures you make. For instance, you can make them landscape when there’s lots of text involved. To do this, you can use the `fig.width` and `fig.height` chunk options to control the, um, width and height of the figures:\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r landscape-plot, fig.width=5, fig.height=3}}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n```\n````\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/landscape-plot-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nThe dimensions are also reflected in RStudio itself when you’re working with inline images, so it’s easy to tinker with different values and rerun the chunk without needing to re-knit the whole document over and over again:\n\n![A 3″×5″ image in RStudio](img/fig-dimensions-rstudio.png){width=90%}\n\n#### Bonus artsy mathy fun: Golden rectangles and golden ratios\n\nBecause I’m a super nerd, I try to make the dimensions of all my landscape images be golden rectangles, which follow the [golden ratio](https://en.wikipedia.org/wiki/Golden_ratio)—a [really amazing ancient number](https://slate.com/technology/2021/06/golden-ratio-phi-irrational-number-ellenberg-shape.html) that gets used [all the time in art and design](https://www.adobe.com/creativecloud/design/discover/golden-ratio.html). [Check out this neat video](https://www.youtube.com/watch?v=wTlw7fNcO-0) or [this one](https://www.youtube.com/watch?v=2tv6Ej6JVho) to learn more. \n\nBasically, a golden rectangle is a special rectangle where if you cut it at a specific point, you get a square and a smaller rectangle that is also a golden rectangle. You can then cut that smaller rectangle at the magic point and get another square and another even smaller golden rectangle, and so on.\n\nMore formally and mathematically, it's a rectangle where the ratio of the height and width of the subshapes are special values. Note how here the blue square is a perfect square with side lengths *a*, while the red rectangle is another smaller golden rectangle with side lengths *a* and *b*:\n\n$$\n\\frac{a + b}{a} = \\frac{a}{b} = \\phi\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```\n## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\n## font family not found in Windows font database\n```\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/golden-rectangle-1.png){fig-align='center' width=40%}\n:::\n:::\n\n\n\nIt turns out that if you do the algebra to figure out that ratio or $\\phi$ (the Greek letter \"phi,\" pronounced as either \"fee\" or \"fie\"), it's this:\n\n$$\n\\phi = \\frac{1 + \\sqrt{5}}{2} \\approx 1.618\n$$\n\nThat's all really mathy, but it's really just a matter of using that 1.618 number with whatever dimensions you want. For instance, if I want my image to be 6 inches wide, I'll divide it by $\\phi$ or 1.618 (or multiply it by 0.618, which is the same thing) to find the height to make a golden rectangle: **6 inches × 0.618 = 3.708 = 3.7 inches**\n\nR can even do the math for you in the chunk options:\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r landscape-plot-golden, fig.width=6, fig.height=(6 / 1.618)}}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n```\n````\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/landscape-plot-golden-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n::: {.callout-tip}\n### Shortcut\n\nIf you can't remember that the magic golden ratio $\\phi$ is 1.618 or the gross complicated $\\frac{1 + \\sqrt{5}}{2}$, you can cheat a little and remember $\\frac{5}{3}$, which is 1.667, which is often close enough.\n:::\n\nI don't do this with *all* my figures, and I often have to fudge the numbers a bit when there are titles and subtitles (i.e. making the height a little taller so that the rectangle around just the plot area still roughly follows the golden ratio), but it makes nice rectangles and [I just think they're neat](https://www.youtube.com/watch?v=DrQqajtiRt4).\n\nFor bonus fun, if you draw a curve between the opposite corners of each square of the golden rectangles, you get something called the [golden spiral or Fibonacci spiral](https://en.wikipedia.org/wiki/Golden_spiral), which is replicated throughout nature and art. Graphic designers and artists often make the dimensions of their work fit in golden rectangles and will sometimes even overlay a golden spiral over their work and lay out text and images in specific squares and rectangles. See [this](https://www.adobe.com/creativecloud/design/discover/golden-ratio.html) and [this](https://www.canva.com/learn/what-is-the-golden-ratio/) for some examples.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/golden-rectangle-spiral-1.png){fig-align='center' width=40%}\n:::\n:::\n\n\n\n### What's the difference between `geom_bar()` and `geom_col()`?\n\nIn exercise 3, you made lots of bar charts to show the counts of words spoken in *The Lord of the Rings* movies. To do this, you used `geom_col()` to add columns to the plots. However, confusingly ggplot has another geom layer named `geom_bar()`, which you'd understandably think you could use to make a bar chart. If you tried using it, though, it probably didn't work.\n\n**Both `geom_col()` and `geom_bar()` make bar graphs, but there's a subtle difference between the two: with `geom_col()`, you have to specify both an `x` and a `y` aesthetic; with `geom_bar()`, you only specify an `x` aesthetic and ggplot automatically figures out the `y` for you.**\n\nHere's a quick example using the `mpg` data. Let's say you want to make a plot that shows the count of cars with different drives (front, rear, and four). With `geom_col()`, you're in charge of calculating those totals first before plotting, typically with `group_by() %>% summarize()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get a count of cars by drive\ncars_by_drive <- mpg %>% \n  group_by(drv) %>% \n  summarize(total = n())\n\n# Specify both x and y\nggplot(cars_by_drive, aes(x = drv, y = total)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/geom-col-example-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nYou can make that same plot with `geom_bar()` instead and let ggplot handle the counting:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Use the full dataset and only specify x, not y\nggplot(mpg, aes(x = drv)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/geom-bar-example-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nIt seems like you'd always want to use `geom_bar()` since the code is so much shorter and you can outsource a lot of the work to ggplot—there's no need to use `group_by()` and `summarize()` and do extra calculations! But that's not necessarily the case!\n\nPersonally, I prefer to use `geom_col()` and do my own calculations anyway because it gives me more control over what is getting calculated. For instance, if I want to plot percentages instead of counts, it's far easier to do that in a separate dataset than somehow hack `geom_bar()` into showing percents. Or if I want to group by multiple things, it's easier to do that with `group_by()` instead of tricking `geom_bar()` into getting it right. Plus I can look at the intermediate `cars_by_drive` data before plotting to make sure everything was calculated correctly.\n\nFor instance, if I want to find the proportion of car drives across the two different years in the dataset, it's a lot easier to create my own y variable with `group_by() %>% summarize()` and use `geom_col()` instead of fiddling around with the automatic settings of `geom_bar()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncars_drive_year <- mpg %>% \n  # Make year a categorical variable instead of a number\n  mutate(year = factor(year)) %>% \n  group_by(drv, year) %>% \n  summarize(total = n()) %>% \n  # Group by year to get the proportions of drives within each year\n  group_by(year) %>% \n  mutate(prop = total / sum(total))\n\n# Specify x and y and use geom_col()\nggplot(cars_drive_year, aes(x = year, y = prop, fill = drv)) +\n  geom_col(position = \"dodge\")\n```\n\n::: {.cell-output-display}\n![](2023-09-12_faqs_week-03_files/figure-html/geom-col-fancy-example-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n### What's the difference between `read_csv()` vs. `read.csv()`?\n\nIn all the code I've given you in this class, you've loaded CSV files using `read_csv()`, with an underscore. In lots of online examples of R code, and in lots of other peoples' code, you'll see `read.csv()` with a period. They both load CSV files into R, but there are subtle differences between them.\n\n`read.csv()` (read dot csv) is a core part of R and requires no external packages (we say that it's part of \"base R\"). It loads CSV files. That's its job. However, it can be slow with big files, and it can sometimes read text data in as categorical data, which is weird (that's less of an issue since R 4.0; it was a *major* headache in the days before R 4.0). It also makes ugly column names when there are \"illegal\" columns in the CSV file—it replaces all the illegal characters with `.`s\n\n::: {.callout-note}\n### Legal column names\n\nR technically doesn't allow column names that (1) have spaces in them or (2) start with numbers. \n\nYou can still access or use or create column names that do this if you wrap the names in backticks, like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmpg %>% \n  group_by(drv) %>% \n  summarize(`A column with spaces` = mean(hwy))\n## # A tibble: 3 × 2\n##   drv   `A column with spaces`\n##   <chr>                  <dbl>\n## 1 4                       19.2\n## 2 f                       28.2\n## 3 r                       21\n```\n:::\n\n:::\n\n`read_csv()` (read underscore csv) comes from {readr}, which is one of the 9 packages that get loaded when you run `library(tidyverse)`. Think of it as a new and improved version of `read.csv()`. It handles big files a better, it doesn't ever read text data in as categorical data, and it does a better job at figuring out what kinds of columns are which (if it detects something that looks like a date, it'll treat it as a date). It also doesn't rename any columns—if there are illegal characters like spaces, it'll keep them for you, which is nice.\n\nMoral of the story: **use `read_csv()` instead of `read.csv()`**. It's nicer.\n\n\n### Why does R keep yelling at me with warnings and messages?\n\nBy now you've seen ominous looking red text in R, like `'summarise()' has grouped output by 'Gender'. You can override using the '.groups' argument` or `Warning: Removed 2 rows containing missing values`, and so on. You might have panicked a little after seeing this and thought you were doing something wrong.\n\nNever fear! You're most likely not doing anything wrong.\n\nR shows red text in the console pane in three different situations:\n\n- **Errors**: When the red text is a legitimate error, it will be prefaced with “Error in…” and will try to explain what went wrong. Generally when there’s an error, the code will not run. For example, if you see `Error in ggplot(...) : could not find function \"ggplot\"`, it means that the `ggplot()` function is not accessible because the package that contains the function (`ggplot2`) was not loaded with `library(ggplot2)` (or `library(tidyverse)`, which loads `ggplot2`). Thus you cannot use the `ggplot()` function without the `ggplot2` package being loaded first.\n- **Warnings**: When the red text is a warning, it will be prefaced with “Warning:” and R will try to explain why there’s a warning. Generally your code will still work, but with some caveats. For example if you create a scatterplot based on a dataset where two of the rows of data have missing entries that would be needed to create points in the scatterplot, you will see this warning: `Warning: Removed 2 rows containing missing values (geom_point)`. R will still produce the scatterplot with all the remaining non-missing values, but it is warning you that two of the points aren’t there.\n- **Messages**: When the red text doesn’t start with either “Error” or “Warning”, it’s just a friendly message. You’ll see these messages when you load R packages or when you read data saved in spreadsheet files with `read_csv()`. These are helpful diagnostic messages and they don’t stop your code from working. This is what `'summarise()' has grouped output by 'Gender'...` is—just a helpful note.\n\nRemember, when you see red text in the console, don’t panic. It doesn’t necessarily mean anything is wrong. Rather:\n\n- If the text starts with “Error”, figure out what’s causing it. Think of errors as a red traffic light: something is wrong!\n- If the text starts with “Warning”, figure out if it’s something to worry about. For instance, if you get a warning about missing values in a scatterplot and you know there are missing values, you’re fine. If that’s surprising, look at your data and see what’s missing. Think of warnings as a yellow traffic light: everything is working fine, but watch out/pay attention.\n- Otherwise, the text is just a message. Read it, wave back at R, and thank it for talking to you. Think of messages as a green traffic light: everything is working fine and keep on going!\n\n\n### How can I hide warnings and messages?\n\nIn general, you'll want to try to deal with errors and warnings, often by adjusting or clarifying something in your code. In your final knitted documents, you typically want to have nice clean output without any warnings or messages. You can fix these warnings and messages in a couple ways: (1) change your code to deal with them, or (2) just hide them.\n\nFor instance, if you do something like this to turn off the fill legend:\n\n```r\n# Not actual code; don't try to run this\nggplot(data = whatever, aes(x = blah, y = blah, fill = blah)) +\n  geom_col() +\n  guides(fill = FALSE)\n```\n\nYou'll get this warning:\n\n```r\n## Warning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" \n## instead as of ggplot2 3.3.4.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was\n## generated.\n```\n\nYou'll still get a plot and the fill legend will be gone and that's great, but the warning is telling you that that code has been deprecated and is getting phased out and will eventually stop working. ggplot helpfully tells you how to fix it: use `guides(fill = \"none\")` instead. Changing that code removes the warning and everything will work just fine:\n\n```r\n# Not actual code; don't try to run this\nggplot(data = whatever, aes(x = blah, y = blah, fill = blah)) +\n  geom_col() +\n  guides(fill = \"none\")\n```\n\nIn other cases, though, nothing's wrong and R is just being talkative. For instance, when you load {tidyverse}, you get a big wall of text:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ─────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.2     ✔ readr     2.1.4\n## ✔ forcats   1.0.0     ✔ stringr   1.5.0\n## ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n## ✔ purrr     1.0.1     \n## ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package to force all conflicts to become errors\n```\n:::\n\n\nThat's all helpful information—it tells you that R loaded 9 related packages for you ({ggplot2}, {dplyr}, etc.). But none of that needs to be in a knitted document. You can turn off those messages and warnings using chunk options:\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r load-packages, warning=FALSE, message=FALSE}}\nlibrary(tidyverse)\n```\n````\n:::\n\n\nThe same technique works for other messages too. In exercise 3, for instance, you saw this message a lot:\n\n```r\n## `summarise()` has grouped output by 'Gender'. \n## You can override using the .groups` argument.\n```\n\nThat's nothing bad and you did nothing wrong—that's just R talking to you and telling you that it did something behind the scenes. When you use `group_by()` with one variable, like `group_by(Gender)`, once you're done summarizing and working with the groups, R ungroups your data automatically. When you use `group_by()` with two variables, like `group_by(Gender, Film)`, once you're done summarizing and working with the groups, R ungroups the last of the variables and gives you a data frame that is still grouped by the other variables. So with `group_by(Gender, Film)`, after you've summarized stuff, R stops grouping by `Film` and groups by just `Gender`. That's all the `summarise() has grouped output by...` message is doing—it's telling you that it's still grouped by something. It's no big deal.\n\nSo, to get rid of the message in this case, you can use `message=FALSE` in the chunk options to disable the message:\n\n\n::: {.cell layout-align=\"center\"}\n\n````{.cell-code}\n```{{r lotr-use-two-groups, message=FALSE}}\nlotr_gender_film <- lotr %>% \n  group_by(Gender, Film) %>% \n  summarize(total = sum(Words))\n```\n````\n:::\n",
    "supporting": [
      "2023-09-12_faqs_week-03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}